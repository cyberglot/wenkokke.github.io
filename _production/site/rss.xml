<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>All The Language</title>
        <link>http://wenkokke.github.io</link>
        <description><![CDATA[Personal website of Wen Kokke]]></description>
        <atom:link href="http://wenkokke.github.io/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sat, 12 Sep 2020 12:00:00 UT</lastBuildDate>
        <item>
    <title>Neural Networks with Cube Cats</title>
    <link>http://wenkokke.github.io/posts/2020-09-12-neural-networks-with-cube-cats.html</link>
    <description><![CDATA[<p>Neural Networks. They’re, uh, pretty pervasive by know, so you’ve probably heard of them, telling you which of your friends is in that picture, and that they know what you wanna text better than you do. But what do they know? Do they know things? <em>Let’s find out!</em></p>
<!--more-->
<p>So uh, it’s kinda important that we talk about <em>discrete</em> versus <em>continuous</em> things first, but I checked Wikipedia, and it just told me that <em>discrete</em> things are things that aren’t continuous. So far duh. But that’s not super helpful, so I guess I’ll have a crack at it.</p>
<h2 id="cubes-and-blobs">Cubes and Blobs</h2>
<p><em>Discrete</em> things are neatly separated. You’ve got your cat cube over here, and your dog cube over there, and the two can meet, that’s fine, they’re friends after all, but they’re separate things.</p>
<div class="cube-pets">
<p><img src="/public/images/cube-cat.png" 
     alt="An adorable little cube cat."/> <img src="/public/images/cube-dog.png" 
     alt="A brave little cube dog."/></p>
</div>
<p>Programmers are really good at telling computers how to solve problems that deal with discrete things. “Got three cat cubes, and you wanna have them in a line from big to small? Sure! Computer, just swap the bigger ones to one side ’til it looks right.”</p>
<div class="cube-pets">
<p><img class="smol" 
     src="/public/images/cube-cat.png"
     alt="It's our old friend, adorable little cube cat!"/> <img class="flip"
     src="/public/images/cube-cat.png" 
     alt="Oh no, it's a really big cube cat!"/> <img class="flip huge" 
     src="/public/images/cube-cat.png" 
     alt="The teensy-weensiest cube kitty!"/></p>
</div>
<p><em>Continuous</em> things are all blobby… Imagine your cat cube and your dog cube melting together in an adorable blob of hug. It’s hard to tell where the cat part of the blob ends and the dog part of the blob starts. It’s just <em>one massive blob of catdog</em>.</p>
<div class="cube-pets">
<p><img class="huge" 
     src="/public/images/blob-of-catdog.png" 
     alt="Oh no, our friends melted! It's one big blog of catdog!"/></p>
</div>
<p>When our cube pets melted, we lost something. We lost the <em>distinction</em>, the fact that cat cube and dog cube were two separate things, and we knew what was part of cube cat and what was part of cube dog. There’s bits of it where you’re like “Well, surely <em>this</em> bit is dog!”, but do you know <em>exactly</em> where to draw the line? That’s a very different kind of problem from what we had before!</p>
<h2 id="pictures-of-cats-dogs-and-non-dogs">Pictures of Cats, Dogs, and Non-Dogs</h2>
<p>Let’s look at an example! You’ve got a bunch of pictures, and you wanna know if they’re pictures of cats, dogs, or of literally anything else. It’s one of these vague, blobby problems. If you wanna explain how to answer questions like “Is this a cat?”, you’re gonna have to explain <em>what a cat is</em>, and that’s surprisingly hard! That’s where neural networks come in! If you just show them enough pictures of cats, dogs, and non-dogs, they can <em>learn what a cat is and isn’t!</em></p>
<p>How does that work?</p>
<p>First, what does a neural network even “see” when we show it a picture? Neural networks only “see” numbers. Specifically, they see a list of numbers with a <em>fixed</em> length, depending on how the network was designed. If we want to build a neural network which can look at cat pictures, we’re gonna have to find a way to turn a cat picture into a such list of numbers. There’s <em>many different ways</em> we can do that:</p>
<ul>
<li><p>We could do a little bit of old-fashioned programming, take the pictures, manually tell the computer how to get certain <em>features</em> from them, and then show the neural network that list of features.</p></li>
<li><p>We can make all the pictures the same size, and take the redness, greenness, and blueness of all their pixels. For a picture with 100-by-100 pixels, that gives us 30.000 numbers! Whew, that’s a long list.</p></li>
<li><p>We can put a bunch of neural networks together! They see lists of numbers, but they also give their answers as lists of numbers, so we can take a <em>whole lot</em> of neural networks that can see <em>tiny squares</em>, and stack them together in a whole big pyramid, each layer looking at the outputs of the layer below it, until the base of the pyramid is big enough to look at the whole picture in one go!<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p></li>
</ul>
<p>Let’s go with that first one, with the features, not ’cuz it’s the best, but ’cuz it is the easiest to understand. For instance, we <em>know</em> that all cube cats are purple, and all cube dogs are pink…</p>
<div class="cube-pets">
<p><img src="/public/images/cube-cat.png" 
     alt="It's cube cat again, but now we realise she's purple."/> <img src="/public/images/cube-dog.png" 
     alt="Oh damn, cube dog is pink!"/></p>
</div>
<p>So, uh, if something is a picture of a cube cat, it’s probably gonna be mostly purple, right? And if something’s a picture of a cube dog, it’s probably gonna be mostly pink. We know how to do that! You just take the <em>average</em> redness, greenness, and blueness of all pixels in the picture! That’s just <em>three numbers!</em></p>
<p>Three numbers. Hmm. That means you can think of every picture treated this way as a point in space. The space of <em>all pictures</em>, pictures of cats, dogs, and non-dogs! The neural network’s job is to draw a shape in that space, such that it captures all the pictures of cats, and none of the pictures of dogs, or non-dogs. That shape then captures what it truly means to be a cube cat! <em>The quintessential shape of catness!</em></p>
<h2 id="drawing-shapes-of-cats">Drawing Shapes of Cats</h2>
<p>Reality is a mess! In theory, we can just let the neural network settle on a nice shape for “cat”, and voilà, we’ve solved the problem… Unfortunately, in reality, there’s a ton of problems…</p>
<h4 id="making-lists-of-numbers">Making Lists of Numbers</h4>
<p>We can’t just reduce our inputs down to <em>three</em> numbers without losing a lot of information. Actually, purple and pink have pretty similar greenness and blueness, so really, we’ve reduced our inputs down to just <em>one</em> relevant value… the amount of red! That means that our network thinks anything with low redness is a cube cat, and anything with high redness is a cube dog! What’s that? This picture of a cube bear’s cube cub? It’s a cat!</p>
<div class="cube-pets">
<p><img src="/public/images/cube-cub.png" 
     alt="It's a teal cube cub, but like, the shade of teal was picked specifically to have the same redness as cube cat's shade of purple."/></p>
</div>
<p>So, uh, clearly our neural network didn’t learn the <em>essence of a what it means to be a cat</em>. It just learned some simple way of telling cube cats and cube dogs apart, that happened to work for both cube pets we showed it. If we want it to learn something more general, we’re gonna have to use some way of turning pictures into lists of numbers which doesn’t lose as much of the information… which probably means we’re gonna need much more than just three numbers. That’s fine, though, that just means we’re drawing shapes in higher-dimensional spaces, with more than three dimensions, but the math for shapes and spaces still works… Let’s pretend we’re still talking about three dimensional space, though, ’cuz it’s so much easier to imagine.</p>
<h4 id="pebbles-and-balloons">Pebbles and Balloons</h4>
<p>We’re gonna have to make sure to show our neural network <em>many</em> pictures of cats, dogs, <em>and non-dogs</em>! When the neural network is looking for the right shape in the space of cats, dogs, and non-dogs, it doesn’t get to see the entire space. All it gets to see is the points that we show it, by showing it sample pictures, and telling it whether that sample is a cat, a dog, or a non-dog. The whole “look for a shape” thing only works if the points we’ve got are a good representation of the quintessential shape of catness… If there even is such a thing…</p>
<p>Imagine our <em>shape</em> like a balloon… just, your average, round balloon. Inside of it are a bunch of unmovable pebbles, just floating there. Those are our cat pictures. If we deflate the balloon, it’s gonna get smaller – <em>so far, so duh</em> – but the cat pebbles won’t budge, so it’s gonna get stretched out over the cat pebbles. Outside of the balloon are a different bunch of unmovable pebbles: our dog pictures. If we inflate the balloon, it’s gonna get bigger, and get stuck on our dog pebbles. So, our collection of pebbles is gonna determine what <em>shapes</em> our balloon can take, and the more pebbles we have, the closer those shapes are gonna be to the quintessential shape of catness!</p>
<p>If we’ve got a <em>whole bunch</em> of pebbles, then there’s only gonna be a tiny bit of wiggle room for us to inflate or deflate the balloon, and whatever we do, it’s gonna be pretty much cat shaped… but if we have very few pebbles, then we’re just gonna get a round balloon, with so much space to move it around in, and so many bad options!<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<h4 id="what-even-is-a-cat">What even is a cat?</h4>
<p>The question “Is this a cat?” is inherently kinda vague. It’s impossible to give a definition that includes all things that are cats and excludes all things that are not cats. It’s more of an “I know one when I see one” kinda deal. However, if you showed humans a bunch of pictures of cats, dogs, and non-dogs, their answers probably agree in the vast majority of cases, but there’s always gonna be edge cases that humans disagree on… Is a cube cat a non-dog? <em>(No.)</em> Is a cube tiger a cube cat? <em>(Prolly.)</em> Is a cube wolf a cube dog? <em>(Prolly not.)</em> What if it’s a real good boy? <em>(Okay, fine.)</em> That means we’re only ever aiming for “most humans agree with this neural network, most of the time, and there aren’t and big surprises.” The thing you’d really rather not have, is where humans are like “this is a picture of a cat, one hundred percent sure, we all agree” and then the neural network is like “dog, for sure.”</p>
<p>Anyway, we’ve gone a long time without a picture of a cube pet, so to see you off, all our little cubey friends! Join us next time, when we talk about Hans, the cleverest little cube horse!</p>
<div class="cube-pets">
<p><img src="/public/images/cube-cat.png" 
     alt="Bye, cube cat!"/> <img class="flip"
     src="/public/images/cube-dog.png" 
     alt="Bye, cube dog!"/> <img src="/public/images/cube-cub.png" 
     alt="Bye, cube cub!"/></p>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>That’s called a <em>convolutional neural network</em>, and it’s used a lot in computer vision.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>I really cannot draw well enough for this… if someone wants to do this is Blender, please…<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></description>
    <pubDate>Sat, 12 Sep 2020 12:00:00 UT</pubDate>
    <guid>http://wenkokke.github.io/posts/2020-09-12-neural-networks-with-cube-cats.html</guid>
    <dc:creator>Wen Kokke</dc:creator>
</item>
<item>
    <title>Paper Girls, Substitution Ciphers, and Frequency Analysis</title>
    <link>http://wenkokke.github.io/posts/2018-12-09-paper-girls-substitution-ciphers-and-frequency-analysis.html</link>
    <description><![CDATA[<p><span class="font-papergirls"> WARNING! IF YOU’RE READING THIS, YOU’RE DOING IT WRONG. CLICK THE LINK, READ IT ON MY BLOG. IT’LL BE WAY LESs CONFUSING. ANYWAY. THIS WEeKEND, I PICKED UP A COPY OF PAPER GIRLS, A MYSTERY/SCIENCE FICTION COMIC ABOUT FOUR GIRLS ON A PAPER ROUTE. WAIT, YOU CAN’T UNDERSTAND ME? OH, FUCK, DOESN’T LOoK LIKE IT. SORrY, LET ME ADJUST. </span></p>
<!--more-->
<p>Ah, I’m so sorry, is this any better? Once again, so sorry, I think I’ve been reading this stuff for too long, think I got carried away… Anyway, I’ll take it from the start. So this weekend, I picked up a copy of <em><a href="https://imagecomics.com/comics/releases/paper-girls-1">Paper Girls</a></em>, a mystery/science fiction comic about four girls on a paper route…</p>
<p><img src="/public/images/PaperGirls_1.jpg" alt="Image from Paper Girls. MacKenzie, smoking, sits on her bicycle, while Erin, KJ, and Tiffany stand behind her." /><br />
</p>
<p>It starts simple. Our four heroes band together to deliver papers on Halloween morning. But it quickly escalates. Testament to this fact, thirty-five pages in we meet three time traveling teenagers, wrapped in black bandages, speaking in <em>these things</em>…</p>
<p><img src="/public/images/PaperGirls_2.png" alt="Image from Paper Girls. Two figures wrapped in dark bandages bend over their fallen friend. Their speech is written using strange glyphs." /><br />
</p>
<p>These glyphs are used for the rest of the book, and—best I can tell—the rest of the series without any real explanation… which leaves me with the following question:</p>
<blockquote>
<p>What in fuck’s name are they saying?</p>
</blockquote>
<p>Wanna guess what today’s topic is? Yep. Welcome to my class, “Help! These letters are all funky! (Part 1, Substitution Ciphers)”.</p>
<p>Now, I’ve done this before. Several years ago, I was given a copy of <em><a href="https://www.goodreads.com/book/show/11161195-johnny-23">Johnny 23</a></em> by Charles Burns which is, euh, a book put together using panels from <em><a href="https://www.goodreads.com/book/show/7814774-x-ed-out">X’ed Out</a></em>, with an entirely new “story” written in strange glyphs… Sound, well, semi-familiar at least?</p>
<p><img src="/public/images/XedOut.jpg" alt="Image from X’ed Out. A person is shown a crying worm by a hooded figure with a wound for a nose. The hooded figure then eats the worm. Their speech is written using strange glyphs." /><br />
</p>
<p>It turns out that what Charles had done was basically a substitution cipher—you make up one crazy glyph for each letter of the alphabet, and then instead of writing letters from the alphabet, you use the alien glyphs you came up with…</p>
<p>Honestly, there’s some pretty good reasons to assume that <em>Paper Girls</em> does the same. Substitution ciphers are really easy to come up with—you basically have to come up with one weird glyph for ever letter in your alphabet. Plus, they get the job done! At least, it’s pretty clear to me that our time traveling teenagers are speaking some arcane language!</p>
<p>Substitution ciphers are pretty easy to solve, but compare that more complex ciphers. We could have the cipher evolve over time, say, shift those sinister glyphs by one every time we turn a page. But… do the characters know what page they’re on? And could you speak a language where the sounds you make to say, say <em>chair</em>, change every few minutes?</p>
<p>What about actual cryptographic ciphers? We might as well be putting random noise on the page! There’s no way any reader would crack anything like that, and no way any human could actually speak, say, <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA-encrypted</a> English.</p>
<p>Ideally, you would construct an entirely new language. Constructed languages have a long and rich history, stretching from the 17th century search for the <a href="https://en.wikipedia.org/wiki/Solresol">Perfect Language</a> to the modern desire to make our <a href="https://en.wikipedia.org/wiki/Klingon_language">Bad Space Russians</a> and <a href="https://en.wikipedia.org/wiki/Valyrian_languages">Magic Romans</a> more compelling. However, constructing a languages takes a <em>serious</em> amount of time and effort, and heaps of linguistics knowledge, so you’ll probably only find this kind of stuff in <em>huge</em> and well-funded projects—or in the works of a guy who really just writes fantasy to justify <a href="https://en.wikipedia.org/wiki/Quenya">his conlanging hobby</a>.</p>
<p>All in all, ciphers aren’t the best way to emulate a new and unfamiliar language, but they are the cheapest… <em>“But how do I crack this stuff?!”</em>, you cry out in frustration. Right, good point. Let’s get back to today’s lecture!</p>
<h1 id="how-do-you-crack-this-stuff">How do you crack this stuff?</h1>
<p>First off, I’ll be writing some Python code in this section. Really, I’m just doing that ’cuz I’m bad at counting. You can do everything I’ll be doing by hand, with just some pen and paper.</p>
<p>The first thing you need to do is get some data. Grab your favourite comic with a cipher in there, and start writing down words. I’ll be using the first five issues of <em>Paper Girls</em> for this, because that’s how far I’ve read.</p>
<pre><code class="highlight"><span class="n">data</span> <span class="o">=</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="o">.</span><span class="n">join</span><span class="p">([</span>
    <span class="s font-papergirls">"GODdAMNIT.",</span>
    <span class="s font-papergirls">"SPLIT UP. WE'Ll MEeT AT THE SECOND FOLDING.",</span>
    <span class="s font-papergirls">"STAY AWAY FROM ME!",</span>
    <span class="s font-papergirls">"STOP!",</span>
    <span class="s font-papergirls">"PLEASE!",</span>
    <span class="s font-papergirls">"YOURE GOING TO GET YOURSELVES KILlED!",</span>
    <span class="s font-papergirls">"YOU PEOPLE ARE OUT OF YOUR",</span>
    <span class="s font-papergirls">"NO",</span>
    <span class="s">…</span>
<span class="p">])</span></code></pre>
<p>And then?</p>
<h3 id="frequency-analysis">Frequency analysis</h3>
<p>Let’s do a wee bit of counting, shall we? First off, we’re gonna blindly assume that spaces mean spaces, apostrophe means apostrophe—I’ve only found one in the entire series so far—and comma means comma. That means we’re not really interested in any of those, so let’s replace them with the empty string. Then, we tally up the number of times each letter occurs, and list them, sorted by frequenceny in descending order.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>letters <span class="op">=</span> re.sub(<span class="vs">r&quot;[\s&#39;,]&quot;</span>,<span class="st">&quot;&quot;</span>,data)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>letters_counts <span class="op">=</span> collections.Counter(letters)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>letters_counts <span class="op">=</span> <span class="bu">sorted</span>(letters_counts.items(), key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<pre><code class="highlight"><span class="p">[(</span><span class="s font-papergirls">'E'</span><span class="p">,</span> <span class="mi">64</span><span class="p">),(</span><span class="s font-papergirls">'T'</span><span class="p">,</span> <span class="mi">50</span><span class="p">),(</span><span class="s font-papergirls">'O'</span><span class="p">,</span> <span class="mi">39</span><span class="p">),(</span><span class="s font-papergirls">'A'</span><span class="p">,</span> <span class="mi">35</span><span class="p">),(</span><span class="s font-papergirls">'I'</span><span class="p">,</span> <span class="mi">33</span><span class="p">),(</span><span class="s font-papergirls">'.'</span><span class="p">,</span> <span class="mi">30</span><span class="p">),(</span><span class="s font-papergirls">'S'</span><span class="p">,</span> <span class="mi">29</span><span class="p">),(</span><span class="s font-papergirls">'L'</span><span class="p">,</span> <span class="mi">29</span><span class="p">),(</span><span class="s font-papergirls">'H'</span><span class="p">,</span> <span class="mi">27</span><span class="p">),(</span><span class="s font-papergirls">'N'</span><span class="p">,</span> <span class="mi">23</span><span class="p">),(</span><span class="s font-papergirls">'R'</span><span class="p">,</span> <span class="mi">22</span><span class="p">),(</span><span class="s font-papergirls">'Y'</span><span class="p">,</span> <span class="mi">20</span><span class="p">),(</span><span class="s font-papergirls">'D'</span><span class="p">,</span> <span class="mi">19</span><span class="p">),(</span><span class="s font-papergirls">'U'</span><span class="p">,</span> <span class="mi">18</span><span class="p">),(</span><span class="s font-papergirls">'G'</span><span class="p">,</span> <span class="mi">14</span><span class="p">),(</span><span class="s font-papergirls">'W'</span><span class="p">,</span> <span class="mi">13</span><span class="p">),(</span><span class="s font-papergirls">'C'</span><span class="p">,</span> <span class="mi">11</span><span class="p">),(</span><span class="s font-papergirls">'M'</span><span class="p">,</span> <span class="mi">10</span><span class="p">),(</span><span class="s font-papergirls">'B'</span><span class="p">,</span> <span class="mi">10</span><span class="p">),(</span><span class="s font-papergirls">'P'</span><span class="p">,</span> <span class="mi">9</span><span class="p">),(</span><span class="s font-papergirls">'V'</span><span class="p">,</span> <span class="mi">8</span><span class="p">),(</span><span class="s font-papergirls">'F'</span><span class="p">,</span> <span class="mi">6</span><span class="p">),(</span><span class="s font-papergirls">'!'</span><span class="p">,</span> <span class="mi">6</span><span class="p">),(</span><span class="s font-papergirls">'K'</span><span class="p">,</span> <span class="mi">6</span><span class="p">),(</span><span class="s font-papergirls">'o'</span><span class="p">,</span> <span class="mi">4</span><span class="p">),(</span><span class="s font-papergirls">'e'</span><span class="p">,</span> <span class="mi">2</span><span class="p">),(</span><span class="s font-papergirls">'J'</span><span class="p">,</span> <span class="mi">2</span><span class="p">),(</span><span class="s font-papergirls">'?'</span><span class="p">,</span> <span class="mi">2</span><span class="p">),(</span><span class="s font-papergirls">'X'</span><span class="p">,</span> <span class="mi">2</span><span class="p">),(</span><span class="s font-papergirls">'d'</span><span class="p">,</span> <span class="mi">1</span><span class="p">),(</span><span class="s font-papergirls">'s'</span><span class="p">,</span> <span class="mi">1</span><span class="p">),(</span><span class="s font-papergirls">'Q'</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span></code></pre>
<p>So if we wanna stick to our guess that this is really just English, but written with silly squiggles, then it’s looking pretty likely that ‘<span class="font-papergirls">E</span>’ is the letter ‘e’, since off the top of my head that’s the most commonly used letter in English. But what’s the rest? I always forget, though I know that the rest of the vowels and the ‘n’ are pretty high up there. We could Google, but, like, why would we? Let’s just grab some English text and count!</p>
<p>(Note: I strongly recommend not doing the next part by hand.)</p>
<p>Cool. Let’s pick some random English text, say <em><a href="https://en.wikipedia.org/wiki/Emma_(novel)">Emma</a></em> by Jane Austen—why not?—and do the exact same thing. We remove spaces, apostrophes, and commas, and while we’re at it, let’s convert the text to lowercase—our eldritch glyphs don’t really <em>look</em> like they have a case distinction.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>letters_emma <span class="op">=</span> <span class="st">&quot; &quot;</span>.join(nltk.corpus.gutenberg.words(<span class="st">&#39;austen-emma.txt&#39;</span>))</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>letters_emma <span class="op">=</span> re.sub(<span class="st">&quot;[\s&#39;,]&quot;</span>,<span class="st">&quot;&quot;</span>,emma).lower()</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>letters_counts_emma <span class="op">=</span> collections.Counter(letters_emma)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>letters_counts_emma <span class="op">=</span> </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>    <span class="bu">sorted</span>(letters_counts_emma.items(), key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>[(<span class="st">&#39;e&#39;</span>, <span class="dv">86021</span>), (<span class="st">&#39;t&#39;</span>, <span class="dv">59201</span>), (<span class="st">&#39;a&#39;</span>, <span class="dv">54379</span>), (<span class="st">&#39;o&#39;</span>, <span class="dv">53199</span>), (<span class="st">&#39;n&#39;</span>, <span class="dv">47288</span>), … ]</span></code></pre></div>
<p>Let’s plot those side by side, see if anything looks off about this.</p>
<p><img src="/public/images/PaperGirls_FA.png" alt="Frequency analysis graphs for single characters in the speech in Paper Girls compared to the speech in Jane Austen’s Emma. The graphs look similar." /><br />
</p>
<p>Great news! The distribution of the letters looks like <em>language</em>. For comparison, if we encrypt <em>Emma</em> and then do frequency analysis, it looks something like this:</p>
<p><img src="/public/images/PaperGirls_Encrypted_FA.png" alt="Frequency analysis graphs for single characters in the speech in Jane Austen’s Emma encrypted compared to the speech in Jane Austen’s Emma unencrypted. The frequency counts for the encrypted speech are virtually uniform." /><br />
</p>
<p>Ok, so hypothesis:</p>
<blockquote>
<p>The frequencies for <em>Paper Girls</em> overlap <em>exactly</em> with those of <em>Emma</em>.</p>
</blockquote>
<p>Let’s test it. First, we build a translation table, and then we apply it to our data.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>trans <span class="op">=</span> {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>    l1: l2 <span class="cf">for</span> (l1, c1), (l2, c2) <span class="kw">in</span> <span class="bu">zip</span>(letters_counts, letters_counts_emma)}</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>data_transed <span class="op">=</span> [</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    <span class="st">&#39;&#39;</span>.join(trans.get(c,c) <span class="cf">for</span> c <span class="kw">in</span> line) <span class="cf">for</span> line <span class="kw">in</span> data.splitlines()]</span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>[</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    <span class="st">&#39;yauqogdnti&#39;</span>,</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    <span class="st">&quot;hpsnt wpi ce&#39;ss ge;t ot tre hefadu vasundyi&quot;</span>,</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>    <span class="st">&#39;htom ocom vlag ge-&#39;</span>,</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>    <span class="st">&#39;htap-&#39;</span>,</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>    <span class="st">&#39;pseohe-&#39;</span>,</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>    <span class="st">&#39;mawle yandy ta yet mawlhes.eh knsseu-&#39;</span>,</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>    <span class="st">&#39;maw peapse ole awt av mawl&#39;</span>,</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>    <span class="st">&#39;da&#39;</span>,</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>    …</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>]</span></code></pre></div>
<p>Ok, so, maybe we’re not so lucky? Eugh, why do these things always have to be hard.</p>
<p>Well, our data is pretty sparse, so it makes sense that these wouldn’t line up precisely, even if our teenagers <em>were</em> speaking English… And I’m not particularily keen on going in and transcribing more, so I guess we’ll just have to do more thinking.</p>
<p>Let’s just assume that we got one or two characters right. Those first peaks look pretty convincing, so let’s assume ‘<span class="font-papergirls">E</span>’ is ‘e’ and ‘<span class="font-papergirls">T</span>’ is ‘t’. What else can we do?</p>
<h3 id="common-words">Common words</h3>
<p>We can have a look at the single-letter words! Let’s pretend we don’t know English. What are common single-letter words, according to <em>Emma</em>?</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>single_letter_words_counts <span class="op">=</span> collections.Counter(</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>    word <span class="cf">for</span> word <span class="kw">in</span> emma.split() <span class="cf">if</span> <span class="bu">len</span>(word) <span class="op">==</span> <span class="dv">1</span> <span class="kw">and</span> word.isalpha())</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>single_letter_words_counts <span class="op">=</span> <span class="bu">sorted</span>(</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    single_letter_words_counts.items(), key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>[(<span class="st">&#39;I&#39;</span>, <span class="dv">3178</span>), (<span class="st">&#39;a&#39;</span>, <span class="dv">3004</span>), (<span class="st">&#39;s&#39;</span>, <span class="dv">933</span>), (<span class="st">&#39;A&#39;</span>, <span class="dv">125</span>), (<span class="st">&#39;t&#39;</span>, <span class="dv">19</span>), (<span class="st">&#39;d&#39;</span>, <span class="dv">12</span>),</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a> (<span class="st">&#39;E&#39;</span>, <span class="dv">11</span>),   (<span class="st">&#39;o&#39;</span>, <span class="dv">8</span>),    (<span class="st">&#39;F&#39;</span>, <span class="dv">4</span>),   (<span class="st">&#39;W&#39;</span>, <span class="dv">4</span>),   (<span class="st">&#39;V&#39;</span>, <span class="dv">3</span>),  … ]</span></code></pre></div>
<p>Ah, yes, the well-known word ‘W’. But at least we can be fairly sure that the only single-letter words which matter in English are ‘I’ and ‘a’, and we didn’t even have to think! Let’s see what single-letter words our data has on offer…</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>single_letter_words <span class="op">=</span> <span class="bu">set</span>(word <span class="cf">for</span> word <span class="kw">in</span> data.split() <span class="cf">if</span> <span class="bu">len</span>(word) <span class="op">==</span> <span class="dv">1</span>)</span></code></pre></div>
<pre><code class="highlight"><span class="p">[</span><span class="s font-papergirls">'I'</span><span class="p">]</span></code></pre>
<p>Well, that’s disappointing, now we have to pick. At least we’re fairly sure now that ‘<span class="s font-papergirls">I</span>’ will turn out to be either ‘i’ or ‘a’.</p>
<p>We can repeat this trick for two letter words, three letter words, four letter words, etc. However, we’ll probably need quite a lot of data for word counts to start looking like your average word counts for English—like those found in <em>Emma</em> and only <em>Emma</em>. Let’s count up the two-letter words, and plot their frequencies:</p>
<p><img src="/public/images/PaperGirls_TwoLetter_FA.png" alt="Frequency analysis graphs for two-letter words in the speech in Paper Girls compared to the speech in Jane Austen’s Emma. The graphs look similar." /><br />
</p>
<p>It’s tempting to assume that those plots align exactly, but we’re dealing with <em>really</em> sparse data at this point. Instead, let’s use the knowledge that we’ve uncovered so far to see if we can find any of those common words. The words ‘<span class="font-papergirls">TO</span>’, ‘<span class="font-papergirls">IT</span>’, and ‘<span class="font-papergirls">AT</span>’ all feature a ‘<span class="font-papergirls">T</span>’. They seem like pretty likely candidates for ‘to’, ‘it’, and ‘at’, so it seems quite likely that ‘<span class="font-papergirls">O</span>’ is ‘o’, and that ‘<span class="font-papergirls">I</span>’ is ‘i’ and ‘<span class="font-papergirls">A</span>’ is ‘a’, or vice versa. Note that ‘<span class="font-papergirls">A</span>’ is the fourth most character, like we’d expect from an ‘i’ or an ‘a’. Based on the frequencies—‘a’ is a more common character than ‘i’, but ‘I’ is a more common word than ‘a’—we can guess that ‘<span class="font-papergirls">I</span>’ is ‘i’ and ‘<span class="font-papergirls">a</span>’ is ‘a’.</p>
<p>We could continue with this trick for quite a while, using three-letter words, four-letter words, bi-grams, tri-grams, etc. However, we could quite quickly run into the problem that the data we have is really quite sparse, and we can only really solve that by reading more <em>Paper Girls</em> and adding more phrases to our database… which… well, the first part of that sounds like fun. However, there is one trick which we can still quite easily exploit…</p>
<h3 id="double-letters">Double letters</h3>
<p>Let’s do some counting of <em>repeated letters</em>, such as the ‘tt’ in letters, and see how those patterns compare to those found in English. We do this by zipping the data with the data offset by one–e.g. from <code>"hello"</code> we would get <code>[('h','e'), ('e','l'), ('l','l'), ('l','o')]</code>—and then picking only the pairs where both letters are the same—in our example, <code>('l','l')</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>doubles <span class="op">=</span> [ l1 <span class="op">+</span> l2 <span class="cf">for</span> l1, l2 <span class="kw">in</span> <span class="bu">zip</span>(data,data[<span class="dv">1</span>:]) <span class="cf">if</span> l1 <span class="op">==</span> l2 ]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>doubles_counts <span class="op">=</span> collections.Counter(doubles)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>doubles_counts <span class="op">=</span> <span class="bu">sorted</span>(doubles_counts.items(), key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<p>You’ve got the hang of this by now—we count doubles in <em>Emma</em> as well, and plot both distributions.</p>
<p><img src="/public/images/PaperGirls_Doubles_FA_1.png" alt="Frequency analysis graphs for bigrams in the speech in Paper Girls compared to the speech in Jane Austen’s Emma. The graph for paper girls has only two entries." /><br />
</p>
<p>Whoa, so something kinda weird is going on here. First off, really? There’s only <em>two</em> characters that are ever repeated? Like, our sample size is small, but not <em>that</em> small. Also, neither of these characters are anything we have a guess for yet… so if our guesses are correct, we don’t have <em>any</em> occurances of ‘ee’ or ‘tt’. Look at the chart for <em>Emma</em>, they’re pretty common.</p>
<p>It may be a good idea to have a closer look at the data. If you scroll up to where we defined <code>data</code>, you’ll find ‘<span class="font-papergirls">Dd</span>’ and ‘<span class="font-papergirls">Ee</span>’, and actually, if we look at all the data, we’ll find ‘<span class="font-papergirls">Oo</span>’ and ‘<span class="font-papergirls">Ss</span>’ as well. These mirrored versions of the characters only seem to appear directly after a neutral versions of the same character, and they look <em>suspiciously</em> like repeated characters. Actually, we should’ve asked this <em>a long time ago</em>. How many characters do we even have?</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>num_characters <span class="op">=</span> <span class="bu">len</span>(letters_counts)</span></code></pre></div>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="dv">32</span></span></code></pre></div>
<p><em>WHAT?!</em> 32 CHARACTERS?! Right, that doesn’t mash with our whole “Latin alphabet” thing. Eugh, let’s finish this “double characters” thing first, and then we’ll look into our surplus of characters.</p>
<p>Let’s count up the double characters <em>and</em> the characters followed by their mirrored image, and plot those against the double characters in <em>Emma</em>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>doubles_or_mirrored <span class="op">=</span> [</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>    l1 <span class="op">+</span> l2 <span class="cf">for</span> l1, l2 <span class="kw">in</span> <span class="bu">zip</span>(data,data[<span class="dv">1</span>:]) <span class="cf">if</span> l1 <span class="op">==</span> l2 <span class="kw">or</span> l1 <span class="op">==</span> l2.mirrored() ]</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>doubles_or_mirrored_counts <span class="op">=</span> collections.Counter(doubles_or_mirrored)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>doubles_or_mirrored_counts <span class="op">=</span> <span class="bu">sorted</span>(</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>    doubles_or_mirrored_counts.items(), key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<p><img src="/public/images/PaperGirls_Doubles_FA_2.png" alt="Frequency analysis graphs for bigrams in the speech in Paper Girls compared to the speech in Jane Austen’s Emma. The graphs look similar." /><br />
</p>
<p>Ah, that makes <em>way</em> more sense. We can still probably assume that ‘<span class="font-papergirls">LL</span>’ is ‘ll’, and it probably makes sense to stick to our guns and say that ‘<span class="font-papergirls">Oo</span>’ is ‘oo’ and ‘<span class="font-papergirls">Ee</span>’ is ‘ee’.</p>
<h3 id="too-many-characters">Too many characters</h3>
<p>Eek! So let’s get to that whole “too many characters thing”. See, if our hypothesis is true, and this is really English, then we’d kinda expect to see at most 26 characters. Realistically, we’d expect more like 20 to 23 characters. For instance, if we check the frequency analysis for letters a while back, we see that ‘v’, ‘k’, ‘x’, ‘j’, ‘q’, and ‘z’ are rarer in English than the full stop.</p>
<p>So what do we do with our bonus characters? Well, if we go with the idea that doubles are mirrored, then that at least takes care of four characters: ‘<span class="font-papergirls">o</span>’, ‘<span class="font-papergirls">e</span>’, ‘<span class="font-papergirls">d</span>’, and ‘<span class="font-papergirls">s</span>’. That takes us down to only 28 characters.</p>
<p>So… four down, at least two to go? The most common non-letter is the full stop, but it’d be a bit weird if the full stop were included in the alphabet, given that the comma and the apostrophe were just written as usual. However, if we look at the data, we find three characters—<span class="font-papergirls">.</span>, <span class="font-papergirls">!</span>, and <span class="font-papergirls">?</span>—which <em>exclusively</em> appear at the end of words, and <em>almost exclusively</em> at the end of the entire speech bubble. Moreover, almost every speech bubble ends with one of these characters, the only exceptions being chapter titles and <em>two</em> other utterances. We can assume that these are ‘.’, ‘!’, and ‘?’, in order of frequency. Honestly, it doesn’t hurt too much if we get these wrong, the only important thing is that—if these truly are punctuation—we don’t try to assign letters to them.</p>
<h3 id="write-down-everything-weve-got">Write down everything we’ve got!</h3>
<p>Right, so, we’ve made quite a few guesses by now, let’s see if that gets us anywhere. First, let’s write down everything we’ve got…</p>
<pre><code class="highlight"><span class="n">trans</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">" "</span><span class="p">:</span> <span class="s">" "</span><span class="p">,</span> <span class="s">"'"</span><span class="p">:</span> <span class="s">"'"</span><span class="p">,</span> <span class="s">","</span><span class="p">:</span> <span class="s">","</span><span class="p">,</span> 
    <span class="s font-papergirls">'A'</span><span class="p">:</span> <span class="s">'a'</span><span class="p">,</span> <span class="s font-papergirls">'E'</span><span class="p">:</span> <span class="s">'e'</span><span class="p">,</span> <span class="s font-papergirls">'e'</span><span class="p">:</span> <span class="s">'e'</span><span class="p">,</span> <span class="s font-papergirls">'T'</span><span class="p">:</span> <span class="s">'t'</span><span class="p">,</span> <span class="s font-papergirls">'I'</span><span class="p">:</span> <span class="s">'i'</span><span class="p">,</span> <span class="s font-papergirls">'o'</span><span class="p">:</span> <span class="s">'o'</span><span class="p">,</span> <span class="s font-papergirls">'O'</span><span class="p">:</span> <span class="s">'o'</span><span class="p">,</span> <span class="s font-papergirls">'L'</span><span class="p">:</span> <span class="s">'l'</span><span class="p">,</span> <span class="s font-papergirls">'.'</span><span class="p">:</span> <span class="s">'.'</span><span class="p">,</span> <span class="s font-papergirls">'!'</span><span class="p">:</span> <span class="s">'!'</span><span class="p">,</span> <span class="s font-papergirls">'?'</span><span class="p">:</span> <span class="s">'?'</span><span class="p">}</span></code></pre>
<p>…and then use that to try and translate our data, replacing anything for which we haven’t made a guess yet with an underscore.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>data_transed <span class="op">=</span> [</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>    <span class="st">&#39;&#39;</span>.join(trans.get(c,<span class="st">&#39;_&#39;</span>) <span class="cf">for</span> c <span class="kw">in</span> line) <span class="cf">for</span> line <span class="kw">in</span> data.splitlines()]</span></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>[<span class="st">&#39;_o__a__it.&#39;</span>,</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a> <span class="st">&quot;__lit __. _e&#39;ll _eet at t_e _e_o__ _ol_i__.&quot;</span>,</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a> <span class="st">&#39;_ta_ a_a_ __o_ _e!&#39;</span>,</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a> <span class="st">&#39;_to_!&#39;</span>,</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a> <span class="st">&#39;_lea_e!&#39;</span>,</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a> <span class="st">&#39;_o__e _oi__ to _et _o___el_e_ _ille_!&#39;</span>,</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a> <span class="st">&#39;_o_ _eo_le a_e o_t o_ _o__&#39;</span>,</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a> <span class="st">&#39;_o&#39;</span>,</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a> …]</span></code></pre></div>
<p>From here, it’s a bit of a word puzzle. For instance, "_e’ll _eet at t_e" looks like it’s saying “we’ll meet at the”. Let’s add those guesses, and translate again, see if they make sense?</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>[<span class="st">&#39;_o__am_it.&#39;</span>,</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a> <span class="st">&quot;__lit __. we&#39;ll meet at the _e_o__ _ol_i__.&quot;</span>,</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a> <span class="st">&#39;_ta_ awa_ __om me!&#39;</span>,</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a> <span class="st">&#39;_to_!&#39;</span>,</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a> <span class="st">&#39;_lea_e!&#39;</span>,</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a> <span class="st">&#39;_o__e _oi__ to _et _o___el_e_ _ille_!&#39;</span>,</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a> <span class="st">&#39;_o_ _eo_le a_e o_t o_ _o__&#39;</span>,</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a> <span class="st">&#39;_o&#39;</span>,</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a> …]</span></code></pre></div>
<p>Does "awa_ __om me" say “away from me”? Let’s see if that makes sense!</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>[<span class="st">&#39;_o__am_it.&#39;</span>,</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a> <span class="st">&quot;__lit __. we&#39;ll meet at the _e_o__ fol_i__.&quot;</span>,</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a> <span class="st">&#39;_tay away from me!&#39;</span>,</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a> <span class="st">&#39;_to_!&#39;</span>,</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a> <span class="st">&#39;_lea_e!&#39;</span>,</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a> <span class="st">&#39;yo_re _oi__ to _et yo_r_el_e_ _ille_!&#39;</span>,</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a> <span class="st">&#39;yo_ _eo_le are o_t of yo_r&#39;</span>,</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a> <span class="st">&#39;_o&#39;</span>,</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a> …]</span></code></pre></div>
<p>Right, <em>stay</em>, as in “stay away from me!” If we’d kept the source text in mind, we would’ve probably seen that. Though I often find it easier to stare only at the underscored text, to not be distracted by these otherworldly glyphs.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>[<span class="st">&#39;_o__am_it.&#39;</span>,</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a> <span class="st">&quot;s_lit __. we&#39;ll meet at the se_o__ fol_i__.&quot;</span>,</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a> <span class="st">&#39;stay away from me!&#39;</span>,</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a> <span class="st">&#39;sto_!&#39;</span>,</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a> <span class="st">&#39;_lease!&#39;</span>,</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a> <span class="st">&#39;yo_re _oi__ to _et yo_rsel_es _ille_!&#39;</span>,</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a> <span class="st">&#39;yo_ _eo_le are o_t of yo_r&#39;</span>,</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a> <span class="st">&#39;_o&#39;</span>,</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a> …]</span></code></pre></div>
<p>Things are starting to get pretty clear. “Stop!”, “Please!”, “youre going to get yourselves killed!”, “you people are out of your”… We can keep doing this, and eventually we’ll manage to find guesses for most of the letters. The authors have even included an ‘x’ and a ‘q’ in such natural words such as ‘vertex’ and ‘tuplequad’. Honestly, that last one took me a while. The ‘ua’ and the fact that it was either gonna be a ‘q’ or a ‘z’ helped.</p>
<h3 id="and-then-you-make-a-nice-table">…and then you make a nice table</h3>
<p>Woo! We’ve done it! We can read the bizzare glyphs in <em>Paper Girls</em> now! And the only letter we’re missing is the ‘z’. Hope I’ll find one of those in one of the later books.</p>
<table style="font-size:xx-large;">
<tbody>
<tr>
<td>
<span class="font-papergirls">A</span>
</td>
<td>
<span class="font-papergirls">B</span>
</td>
<td>
<span class="font-papergirls">C</span>
</td>
<td>
<span class="font-papergirls">D</span>
</td>
<td>
<span class="font-papergirls">E</span>
</td>
<td>
<span class="font-papergirls">F</span>
</td>
<td>
<span class="font-papergirls">G</span>
</td>
<td>
<span class="font-papergirls">H</span>
</td>
<td>
<span class="font-papergirls">I</span>
</td>
<td>
<span class="font-papergirls">J</span>
</td>
</tr>
<tr>
<td>
a
</td>
<td>
b
</td>
<td>
c
</td>
<td>
d
</td>
<td>
e
</td>
<td>
f
</td>
<td>
g
</td>
<td>
h
</td>
<td>
i
</td>
<td>
j
</td>
</tr>
<tr>
<td>
<span class="font-papergirls">K</span>
</td>
<td>
<span class="font-papergirls">L</span>
</td>
<td>
<span class="font-papergirls">M</span>
</td>
<td>
<span class="font-papergirls">N</span>
</td>
<td>
<span class="font-papergirls">O</span>
</td>
<td>
<span class="font-papergirls">P</span>
</td>
<td>
<span class="font-papergirls">Q</span>
</td>
<td>
<span class="font-papergirls">R</span>
</td>
<td>
<span class="font-papergirls">S</span>
</td>
<td>
<span class="font-papergirls">T</span>
</td>
</tr>
<tr>
<td>
k
</td>
<td>
l
</td>
<td>
m
</td>
<td>
n
</td>
<td>
o
</td>
<td>
p
</td>
<td>
q
</td>
<td>
r
</td>
<td>
s
</td>
<td>
t
</td>
</tr>
<tr>
<td>
<span class="font-papergirls">U</span>
</td>
<td>
<span class="font-papergirls">V</span>
</td>
<td>
<span class="font-papergirls">W</span>
</td>
<td>
<span class="font-papergirls">X</span>
</td>
<td>
<span class="font-papergirls">Y</span>
</td>
<td>
<span class="font-papergirls">_</span>
</td>
<td>
<span class="font-papergirls"> </span>
</td>
<td>
<span class="font-papergirls">.</span>
</td>
<td>
<span class="font-papergirls">!</span>
</td>
<td>
<span class="font-papergirls">?</span>
</td>
</tr>
<tr>
<td>
u
</td>
<td>
v
</td>
<td>
w
</td>
<td>
x
</td>
<td>
y
</td>
<td>
z
</td>
<td>
</td>
<td>
.
</td>
<td>
!
</td>
<td>
?
</td>
</tr>
</tbody>
</table>
<p>Wrapping up, what have we learned? I guess the important things are that you can pretty easily crack any substitution cipher by boldly making some assumptions about what the language is, and then exploiting letter frequencies from that language… and that you can exploit way more than just <em>plain</em> letter freqencies—short words, n-grams, repeated characters, they’re all good candidates for frequency analysis.</p>
<p>Also… <em>Paper Girls</em> is fucking rad, go read that shit.</p>]]></description>
    <pubDate>Sun, 09 Dec 2018 12:00:00 UT</pubDate>
    <guid>http://wenkokke.github.io/posts/2018-12-09-paper-girls-substitution-ciphers-and-frequency-analysis.html</guid>
    <dc:creator>Wen Kokke</dc:creator>
</item>
<item>
    <title>VISL CG-3 is the new assembler</title>
    <link>http://wenkokke.github.io/posts/2017-05-15-visl-cg-3-is-the-new-assembler.html</link>
    <description><![CDATA[<p>This post is a continuation of <em><a href="/posts/2016-03-16-constraint-grammar-can-count.html">Constraint Grammar can count!</a></em>, in which I talked a bunch about how expressive constraint grammar is. Now, for most of that post, what I actually meant was the fragment of constraint grammar where you only use the <code>REMOVE</code> rule. However, I always had the suspicion that I’d be pretty easy to simulate a Turing machine using only the <code>ADDCOHORT</code> and <code>REMCOHORT</code> commands, treating the list of cohorts as the Turing machine’s tape—and I don’t think I was the only one to feel that way.</p>
<!--more-->
<p>Now, this would be wonderful news. It would prove that <code>ADDCOHORT</code> and <code>REMCOHORT</code> are Turing-complete—given that VISL CG-3 itself is a pretty decent proof that we can run constraint grammars on a universal computer. Not only that, but VISL CG-3 is an extremely optimized piece of software—so the fact that we could compile <em>any Turing machine</em> to VISL CG-3 would be great news for the HPC community<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>With all this in mind, I decided to finally work out the details of this compiler I had had tumbling around in my brain for the past months. Turns out, it’s kinda nice.</p>
<p>For this post, we’ll encode the first Turing machine program I could find, using a quick search, as a constraint grammar, using only <code>ADDCOHORT</code> and <code>REMCOHORT</code><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> I’ll try to explain the general principle as we go. But first, I should probably briefly go over how a Turing machine works—though I hope you’ll forgive me if I’ll be a little informal. <em>Heads-up</em>: If you don’t want to read through a whole bunch about Turing machines, it’s probably best to skip right to <a href="#visl-cg-3-turing-machines">the meat</a>.</p>
<h1 id="so-whats-this-turing-machine-business">So what’s this Turing machine business?</h1>
<p>A Turing machine is a tiny machine, which sits whirring away on top of an infinite roll of tape. It has a head, which hoovers over the tape, and reads and writes whatever cell it happens to hoover over. It also has a state. This is basically saying that it can remember what it was doing, but practically speaking this’ll be some number. The number of the thing it was supposed to be doing. It was never supposed to be built, but of course someone did:</p>
<p><img src="/public/images/Model_of_a_Turing_machine.jpg" alt="An actual Turing machine." /><br />
</p>
<p>Actually, many people have built one. Out of everything from <a href="https://web.archive.org/web/20150924052601/https://www.newscientist.com/blogs/nstv/2011/03/turing-machine-built-from-wood-and-scrap-metal.html">wood and scrap metal</a>, to <a href="http://web.archive.org/web/20170513045644/http://www.legoturingmachine.org/lego-turing-machine/">Legos</a>, to <a href="http://dx.doi.org/10.1063/1.4793648">artificial muscle</a>.</p>
<p>Anyway. What makes every Turing machine special is that each has it’s own unique table, which contains its own unique program. At every step, the Turing machine will use its head to read the cell it’s hoovering over, and then sorta feel its state, and it will consult the great big (or sometimes small) table of its program. The table will then tell it what to do. What it should write over the thing it just read, what its next state should be, and whether it should whirr the tape to the left or to the right. It’ll do this until the table says it should enter its stop state. Then it stops. Some Turing machines have faulty tables, which never let it reach a stopping state.</p>
<p>Now, it just so happens that the first search result for “Turing machine example program” on the day I wrote this post was a machine which increments binary numbers, and its table looked like this:</p>
<p><a href="https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/turing-machine/four.html"><img src="/public/images/BitSuccTM.png" alt="Transition function for a Turing machine which computes the binary successor." /></a></p>
<p>These programs are a little hard to read, so let’s go over what the Turing machine will be doing at each of these states.</p>
<p><strong>State 0</strong> The machine expects its input—that number we’re going to increment—to already be written on the tape. However, it doesn’t trust us to place its head directly at the beginning of said number. So, state 0 is there so that wherever in the number we put its head, it will move right to the start. Then it continues in state 1.</p>
<p><strong>State 1</strong> All the real work is done in state 1. In state 1, the Turing machine is in the business of progressivly moving its head to the right. It will overwrite any <code>1</code> it meets with a <code>0</code>. But if it <em>ever</em> reads a <code>0</code> or a blank, it will write a <code>1</code> and continue in state 2.</p>
<p><strong>State 2</strong> A brief check with your binary arithmetic will tell you we’ve already incremented the number in the previous state. So what is state 2 there for? It does the same thing as state 0. For reasons of cleanliness, and being a good bot, it moves its head back to the beginning of the number. And when it has done that, it stops.</p>
<p>Below is the trace for the machine incrementing the number 11 to 12, or <code>1011</code> to <code>1100</code> in binary. I’ve put a 🤖, to show you where the machine is looking:</p>
<pre><code>_	_ 🤖	1	1	0	1 # 0: Read 1, Write 1, Move ←
_ 🤖	_	1	1	0	1 # 0: Read _, Write _, Move →
_	_ 🤖	1	1	0	1 # 1: Read 1, Write 0, Move →
_	_	0 🤖	1	0	1 # 1: Read 1, Write 0, Move →
_	_	0	0 🤖	0	1 # 1: Read 0, Write 1, Move ←
_	_	0 🤖	0	1	1 # 2: Read 0, Write 0, Move ←
_	_ 🤖	0	0	1	1 # 2: Read 0, Write 0, Move ←
_ 🤖	_	0	0	1	1 # 2: Read _, Write _, Move →
_	_ 🤖	0	0	1	1 # Stop</code></pre>
<p>Great! So now we’ve got that out of the way, let’s have a look at implementing this machine in VISL CG-3, because why not?</p>
<h1 id="visl-cg-3-turing-machines">VISL CG-3 Turing Machines</h1>
<p>We’re going to represent the Turing machine’s tape as a list of cohorts. This means that when we pass in the number 11, we pass VISL CG-3 the following text:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;1&quot;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="co">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;1&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="co">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;0&quot;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="co">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;1&quot;</span></span></code></pre></div>
<p>We will take a cue from the nice infix notation we used above, and write the current state to the tape, right before the cell which the head is currently on. For instance, the third row in the execution trace above would be written as:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="co">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;0&quot;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="co">&quot;&lt;State&gt;&quot;</span> <span class="st">&quot;State1&quot;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="co">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;1&quot;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="co">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;0&quot;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a><span class="co">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;1&quot;</span></span></code></pre></div>
<p>To start off, our constraint grammar will add a cohort for the start state. It’ll add it right before the first cell of our input. This kind-of makes the whole of state 0 superfluous, but we’ll keep it anyway, for good form:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>BEFORE<span class="op">-</span>SECTIONS</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>ADDCOHORT (<span class="st">&quot;&lt;State&gt;&quot;</span> <span class="st">&quot;State0&quot;</span>) BEFORE (<span class="st">&quot;&lt;Cell&gt;&quot;</span>) IF (<span class="op">-</span><span class="dv">1</span> (<span class="op">&gt;&gt;&gt;</span>))<span class="op">;</span></span></code></pre></div>
<p>Now the meat. We will encode the program of our Turing machine. This is a recursive specification, we we’ll need to wrap it in a <code>SECTION</code>. First, we mark the current state cohort and the cell we’re reading as old:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>ADD (<span class="st">&quot;&lt;State&gt;&quot;</span> <span class="st">&quot;OLD&quot;</span>) (<span class="st">&quot;&lt;State&gt;&quot;</span>)<span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>ADD (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;OLD&quot;</span>) (<span class="st">&quot;&lt;Cell&gt;&quot;</span>) IF (<span class="op">-</span><span class="dv">1</span> (<span class="st">&quot;&lt;State&gt;&quot;</span> <span class="st">&quot;OLD&quot;</span>))<span class="op">;</span></span></code></pre></div>
<p>I realise that these are <code>ADD</code> commands, and I promised to only use <code>ADDCOHORT</code> and <code>REMCOHORT</code>, but hear me out. We can simulate this usage of <code>ADD</code> by adding a cohort <code>"&lt;Old&gt;"</code> <em>after</em> the cohort we’re marking. However, every time we now select a cohort using e.g. <code>("&lt;Cell&gt;" "OLD")</code>, we’d have to change this to <code>(0 ("&lt;Cell&gt;") LINK 1 ("&lt;Old&gt;"))</code>… and we’d have to take into account the expected number of <code>"&lt;Old&gt;"</code> cohorts, and move every selection by that. Anyway, it wouldn’t be pretty. So please allow me this one thing. Ok?</p>
<p>Back to our scheduled program. Once we’ve marked our old state cohort and the cell we’re reading as old, we can introduce new ones. We will compile every single entry in the Turing machine’s program to <em>two</em> rules. One which introduces the next state, and one which writes a new cell to replace the old one. For instance, the rule which says that “if we are in state 1, and we read a 1, then we write a 0, move the tape to the right, and continue in state 1,” is compiled to the following two rules:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>ADDCOHORT (<span class="st">&quot;&lt;State&gt;&quot;</span> <span class="st">&quot;State1&quot;</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>   BEFORE (<span class="st">&quot;&lt;Cell&gt;&quot;</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>       IF (<span class="op">-</span><span class="dv">2</span> (<span class="st">&quot;&lt;State&gt;&quot;</span> <span class="st">&quot;State1&quot;</span> <span class="st">&quot;OLD&quot;</span>) LINK</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>            <span class="dv">1</span> (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;1&quot;</span> <span class="st">&quot;OLD&quot;</span>))<span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>ADDCOHORT (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;0&quot;</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>    AFTER (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;1&quot;</span> <span class="st">&quot;OLD&quot;</span>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>       IF (<span class="op">-</span><span class="dv">1</span> (<span class="st">&quot;&lt;State&gt;&quot;</span> <span class="st">&quot;State1&quot;</span> <span class="st">&quot;OLD&quot;</span>))<span class="op">;</span></span></code></pre></div>
<p>And the rule which says that “if we are in state 1, and we read a blank, then we write a 1, move the tape to the left, and change to state 2” is compiled to the following two rules:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>ADDCOHORT (<span class="st">&quot;&lt;State&gt;&quot;</span> <span class="st">&quot;State2&quot;</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>   BEFORE (<span class="st">&quot;&lt;Cell&gt;&quot;</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>       IF (<span class="dv">1</span> (<span class="st">&quot;&lt;State&gt;&quot;</span> <span class="st">&quot;State1&quot;</span> <span class="st">&quot;OLD&quot;</span>) LINK</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>           <span class="dv">1</span> (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;_&quot;</span> <span class="st">&quot;OLD&quot;</span>))<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>ADDCOHORT (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;1&quot;</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>    AFTER (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;_&quot;</span> <span class="st">&quot;OLD&quot;</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>       IF (<span class="op">-</span><span class="dv">1</span> (<span class="st">&quot;&lt;State&gt;&quot;</span> <span class="st">&quot;State1&quot;</span> <span class="st">&quot;OLD&quot;</span>))<span class="op">;</span></span></code></pre></div>
<p>In both pairs, the first rule inserts the next state in the appropriate place, and the second rule inserts the newly written cell after the one marked as old.</p>
<p>After all these rules—of which at most one pair will match, because we check for both the state and the cell marked as old—we clean up, simply removing every cohort marked as old:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>REMCOHORT (<span class="st">&quot;&lt;State&gt;&quot;</span> <span class="st">&quot;OLD&quot;</span>)<span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>REMCOHORT (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;OLD&quot;</span>)<span class="op">;</span></span></code></pre></div>
<p>This cycle of marking as old, applying the transitions, and removing the old cohorts will repeat until there are no further changes. Since there are no transitions which match on a stop state, the repetitions will stop here, and the stop state will be marked as old and removed.</p>
<p>Finally, because moving the head back to the start of the number is rather pointless in this implementation, we have a final cleanup step. We remove any leading or trailing blank cells:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>AFTER<span class="op">-</span>SECTIONS</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>REMCOHORT (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;_&quot;</span>) IF (NOT <span class="op">-</span><span class="dv">1</span><span class="op">*</span> SYMB)<span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>REMCOHORT (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;_&quot;</span>) IF (NOT  <span class="dv">1</span><span class="op">*</span> SYMB)<span class="op">;</span></span></code></pre></div>
<p>Hooray! We’ve implemented a Turing machine! Or have we? There’s one tiny issue with the above implementation. Our little Turing machine sits whirring on top of an <em>infinite</em> amount of tape. Here, our implementation only ever writes to cells which were already filled in the input. This means we’ve actually been implementing a linear bounded automaton all this time—i.e. we’ve proven that <code>ADDCOHORT</code> and <code>REMCOHORT</code> cover at least the context-sensitive languages! But really, we’d like to be able to simulate Turing machines, so…</p>
<p>There is a simple way to extend this framework to Turing machines. We add two rules, <em>right</em> at the start of the <code>SECTION</code>, which simply add more blank cells to the edges of the tape whenever the head gets too close:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>ADDCOHORT (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;_&quot;</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>   BEFORE (<span class="st">&quot;&lt;State&gt;&quot;</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>       IF (<span class="op">-</span><span class="dv">1</span> (<span class="op">&gt;&gt;&gt;</span>))<span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>ADDCOHORT (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;_&quot;</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>    AFTER (<span class="st">&quot;&lt;Cell&gt;&quot;</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>       IF (<span class="dv">0</span> (<span class="op">&lt;&lt;&lt;</span>) LINK <span class="op">-</span><span class="dv">1</span> (<span class="st">&quot;&lt;State&gt;&quot;</span>))<span class="op">;</span></span></code></pre></div>
<p>The first of these rules adds a blank cell at the beginning if the state cohort is the <em>first</em> cohort. The second adds a blank cell at the end if the state cohort is the second-to-last cohort—because, remember, we are reading the cell right after the cohort.</p>
<p>Now if you’re thinking “VISL CG-3 is known for being fast; I can’t wait to compile all my code to it!” then I have to tell you—way ahead of you. I’ve implemented this TM to CG compile as a small Haskell library, in addition to a small Turing machine interpreter, so you can really see just <em>how</em> much time you’re saving. I’ve also implemented my example machine, the binary successor function, and wrote a set of QuickCheck functions which compare:</p>
<ul>
<li>Haskell’s <code>(+1)</code>;</li>
<li>the interpreted binary successor machine; and</li>
<li>the compiled binary successor in VISL CG-3.</li>
</ul>
<p>Turns out, everthing works!<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> If you want to have a go—maybe implement that sorting algorithm so you can <em>really</em> do a speed comparison—the library is available <a href="https://github.com/wenkokke/cgtm">on my Github</a>, and you can get VISL CG-3 <a href="http://beta.visl.sdu.dk/cg3/chunked/installation.html">on the internet</a>.</p>
<hr />
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>No, it wouldn’t.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Well, those and the <code>ADD</code> command—we can theoretically encode our use of <code>ADD</code> with <code>ADDCOHORT</code>, but it really doesn’t get any prettier if we do so.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>For the binary successor machine.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></description>
    <pubDate>Mon, 15 May 2017 12:00:00 UT</pubDate>
    <guid>http://wenkokke.github.io/posts/2017-05-15-visl-cg-3-is-the-new-assembler.html</guid>
    <dc:creator>Wen Kokke</dc:creator>
</item>
<item>
    <title>Presidents, Scumbags, Kings and Arseholes, and The Great Dalmuti</title>
    <link>http://wenkokke.github.io/posts/2016-04-05-presidents-scumbags-kings-and-arseholes-and-the-great-dalmuti.html</link>
    <description><![CDATA[<p>One of my favourite card games is <a href="https://boardgamegeek.com/boardgame/929/great-dalmuti">The Great Dalmuti</a>. It’s a variant of a widely-played card game with many, many names: President, Scumbag, Kings and Arseholes. Each of these may have <em>slightly</em> different rules, and <em>slightly</em> different decks, but they are all more or less the same game.</p>
<p>I’ve had a bunch of discussions about this game over the years, most of which were about the possible strategies. Personally, I don’t believe that this game is all that hard to play well—and consequently, that it isn’t all that hard to write an AI for it. Pehaps even a very simple, rule-based AI can play passably. However, friends of mine think that it is a much harder problem, and that much more advanced techniques will be needed. Therefore, I thought I’d write a little playground for AIs to play in.</p>
<!--more-->
<p>I’ll get back to that later in this post, though if you’re familiar with the game, you may as well <a href="#an-ai-playground">skip the next section</a>.</p>
<h2 id="the-rules">The Rules</h2>
<p>Before I get to showcasing my playground, it’s probably prudent to at least briefly talk about the game. The rules of the game are fairly simple, so I’ll summarise them here:</p>
<ul>
<li><strong>Rank</strong>: Each player has a rank, with the top ranks usually called something like “president” and “vice president”, and the lower ranks called something like “scumbag” and, well, “vice scumbag”;</li>
<li><strong>Setup</strong>: To start the game, <em>all the cards</em> in the deck are distributed evenly amongst the players; the highest ranking player then starts the first round;</li>
<li><strong>Rounds</strong>: Starting with the player who starts that round (obviously) each player either plays some cards or passes, and the turn passing to the next in rank (after the lowest rank, the turn passes to the highest in rank);</li>
<li><strong>Legal Plays</strong>: A play is legal if:
<ul>
<li>it is the first play, and the cards are all identical in number; or</li>
<li>there are previous plays, the new play has the same number of cards as the previous plays, and all of the cards in the play are the identical in number and strictly “better” than those of the previous play.</li>
</ul></li>
<li><strong>Winning the Round</strong>: Once there is an entire round of passes, the player who was the last to play cards wins the round, and starts the next one;</li>
<li><strong>Winning the Game</strong>: The goal is for players to get rid of all of their cards as fast as possible. The order in which they do so, determines their ranks in the next game, with the first player to finish becoming the highest in rank, the second the second highest, and so on.</li>
</ul>
<p>Each variant of the game adds their own rules to this, but this much is shared by more or less all of them. Note that I haven’t said anything about what cards there are in the deck—this is because every variant is played with a different deck, and with different rules as to which card is “better” than which other. I’ve played many variants of this game, but there’s just something pleasing about the deck The Great Dalmuti uses—one one, two twos, three threes, up to twelve twelves—plus, I own a copy of it, so why not use it as an example? Anyway, The Great Dalmuti adds the following rules:</p>
<ul>
<li><strong>Deck</strong>: It uses the deck outlined above (with one one, two twos, three threes, up to twelve twelves). Confusingly, the lower cards are “better”, so a <code>1</code> is better than a <code>5</code>, which in turn is better than a <code>12</code>;</li>
<li><strong>Jokers</strong>: There are two jokers, which are counted as a <code>13</code> when played by themselves. However, they can be used to complete any set. For instance, <code>[3,13,13]</code> is a legal set of three threes;</li>
<li><strong>Taxation</strong>: Before the game starts, there is a “taxation”. During taxation, The lowest ranking player gives their two <em>best</em> cards to the highest ranking player, and gets any two cards in return. The second lowest and second highest player exchange a <em>single card</em> in a similar manner;</li>
<li><strong>Revolution</strong>: Before the taxation, there is a check. If any player has <em>both</em> jokers in their hand, they may cry “Revolution!” If this happens, the taxation phase is skipped; if the lowest ranking player cries “Revolution!”, instead of skipping the taxation, there is an actual revolution—the lowest ranking player changes places with the highest ranking player, and the second lowest ranking player changes places with the second highest ranking player.</li>
</ul>
<h2 id="an-ai-playground">An AI Playground</h2>
<p>As I mentioned above, I feel that a very simple, rule-based AI could already competently play The Great Dalmuti. As a first step in demonstrating this, I’ve written a small playground where AIs can compete with one another. Below, you should see a number of tabs, the first of which is labelled ‘Console’. In it, there should be a button that looks like this: <span class="runmain">▶</span>. If you click it, the AIs in the other tabs will be pitted against one another in a game of The Great Dalmuti. Try it!</p>
<p><img src="/public/images/dalmuti-example.png" alt="Screenshot of UI of embedded The Great Dalmuti after an example run." /><br />
</p>
<p>In implementing the game, I’ve made one small concession—while it isn’t <em>technically</em> forbidden by the original rules, most players would probably say that a pass isn’t a legal opening move. Why would you? However, in order to keep faulty AIs from breaking up the flow of the game, I’ve implemented it such that <em>it is</em>. This means that, in the game above, if your AI attempts an illegal move, or throws an error, it is taken as a pass instead. Furthermore, if your AI attempts to abuse the taxation system by giving away too many or too few cards, it is instead penalised by giving <em>the best cards.</em></p>
<p>The default AIs—for now—are a little disappointing. There are some functions built into my implementation. Most interestingy, <code>playWorstCards</code> and <code>giveWorstCards</code> both pick whatever your worst possible cards are, and dump them. They’re not incredibly intelligent in doing so, but they’re the best thing that comes with the playground. These functions form Abby and Ezra’s AIs, so amongst the default implementations, they’re the only ones who really have a shot.</p>
<p>Much worse are <code>playBestCards</code> and <code>giveBestCards</code>, which make up Neil’s AI, eager as he is to show how great his cards are, even if it means giving them to other players. And then finally, there’s Ruth. She’s just very nice, and wants to give other players a chance, so she’s been written to pass every turn, even if she’s starting a round. And when it comes to giving away cards, she just gives away the cards that she would be happiest receiving. So, you know, obviously there’s some room for improvement in the department. At least, if competitive play is your goal.</p>
<h2 id="write-your-own-ai">Write your own AI</h2>
<p>I’d love to make it easy for you, and tell you that you can write your AI in <em>any</em> language you want, but the matter of the fact is that you’re reading this on what is basically a huge JavaScript interpreter. So AIs are written in JavaScript.</p>
<p>If you have a look at the code of, for instance, Ezra, you will see that what you need to define is an object with two functions: <code>play</code> and <code>give</code>. The play function is given your player name (just for your convenience) and an object representing the current game state. A <code>game</code> object usually looks something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>game <span class="op">=</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>    { <span class="dt">active</span>   <span class="op">:</span> [<span class="st">&#39;Abby&#39;</span><span class="op">,</span><span class="st">&#39;Ezra&#39;</span><span class="op">,</span><span class="st">&#39;Neil&#39;</span><span class="op">,</span><span class="st">&#39;Ruth&#39;</span>]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    <span class="op">,</span> <span class="dt">finished</span> <span class="op">:</span> []</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    <span class="op">,</span> <span class="dt">ranks</span>    <span class="op">:</span> [<span class="st">&#39;Neil&#39;</span><span class="op">,</span><span class="st">&#39;Ruth&#39;</span><span class="op">,</span><span class="st">&#39;Abby&#39;</span><span class="op">,</span><span class="st">&#39;Ezra&#39;</span>]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="op">,</span> <span class="dt">plays</span>    <span class="op">:</span> [ [<span class="st">&#39;Ruth&#39;</span><span class="op">,</span>[]]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>                 <span class="op">,</span> [<span class="st">&#39;Neil&#39;</span><span class="op">,</span>[<span class="dv">5</span><span class="op">,</span><span class="dv">5</span>]]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>                 <span class="op">,</span> [<span class="st">&#39;Ezra&#39;</span><span class="op">,</span>[<span class="dv">11</span><span class="op">,</span><span class="dv">11</span>]]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>                 <span class="op">,</span> [<span class="st">&#39;Abby&#39;</span><span class="op">,</span>[<span class="dv">12</span><span class="op">,</span><span class="dv">12</span>]]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>                 ]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>    <span class="op">,</span> <span class="dt">hands</span>    <span class="op">:</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>        { <span class="dt">Ezra</span> <span class="op">:</span> [<span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span>]</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>        <span class="op">,</span> <span class="dt">Neil</span> <span class="op">:</span> [<span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span>]</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>        <span class="op">,</span> <span class="dt">Abby</span> <span class="op">:</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">,</span><span class="dv">6</span><span class="op">,</span><span class="dv">6</span><span class="op">,</span><span class="dv">7</span><span class="op">,</span><span class="dv">8</span><span class="op">,</span><span class="dv">8</span><span class="op">,</span><span class="dv">9</span><span class="op">,</span><span class="dv">9</span><span class="op">,</span><span class="dv">9</span><span class="op">,</span><span class="dv">10</span><span class="op">,</span><span class="dv">10</span><span class="op">,</span><span class="dv">11</span><span class="op">,</span><span class="dv">11</span>]</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>        <span class="op">,</span> <span class="dt">Ruth</span> <span class="op">:</span> [<span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span>]</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a>        }</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a>    }</span></code></pre></div>
<p>As you can see, <code>game</code> tells you which players are still in the game, and in which order they’re up (spoiler: you’re first) and who have already finished. Furthermore, it tells you the players’ original ranks (in this case, Neil is top chicken).</p>
<p>Using <code>game.plays</code>, you can find out what the players who have gone before you have played. As you can see, before you came Ruth, who passed—no surprises there—and before that, Neil played two fives. Before that came Ezra, and before that Abby, who started the round by playing two twelves.</p>
<p>Last, there’s a field called “hands”. Obviously, some meddling has gone on here, since no, the other players aren’t holding hands full of zeros. However, isn’t this a quaint way of showing how many cards they are holding? And in addition, your get to see your own hand! Just call <code>game.hands[player]</code>!</p>
<p>The second function, <code>give</code> is much simpler. You’re given your hand of cards, and some number n, and you have to choose n cards to give away. The usual implementation is <code>giveWorstCards</code>, which simply opts to give away your worst cards, potentially breaking up a set. Obviously, this is not quite optimal—it may, e.g. break up a set of three to leave you with <em>one</em> twelve, or it may give away two perfectly good twelves while you have a single eleven and ten.</p>
<p>As a final tip for this section: there’s a function built into my implementation of The Great Dalmuti, <code>allPlays(allowSplit,game)</code>, which returns all legal moves. The second argument, <code>game</code>, is simply the game state that you’ve been passed. The first argument, <code>allowSplit</code>, is a boolean flag. If <code>allowSplit</code> is set to true, then the returned moves will include moves which break up sets. Otherwise, well, it won’t.</p>
<h2 id="join-in-on-the-fun">Join in on the fun!</h2>
<p>Let me leave you with a small snippet of JavaScript. The below code, if copied into one of the AI slots above—I recommend Ruth—will allow you to join in on the fun! It will prompt you, ever time it’s your move, with a request as to which move you’d like to make:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>({</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>    <span class="dt">play</span> <span class="op">:</span> <span class="kw">function</span>(player<span class="op">,</span>game) {</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>        <span class="kw">var</span> hand <span class="op">=</span> <span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(game<span class="op">.</span><span class="at">hands</span>[player])<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>        <span class="kw">var</span> play <span class="op">=</span> <span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(<span class="fu">playWorstCards</span>(game))<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>        <span class="kw">var</span> resp <span class="op">=</span> <span class="bu">JSON</span><span class="op">.</span><span class="fu">parse</span>(</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>            <span class="fu">prompt</span>( <span class="st">&quot;Your hand is &quot;</span><span class="op">+</span>hand<span class="op">+</span><span class="st">&quot;.</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>                  <span class="op">+</span> <span class="st">&quot;What would you like to play?&quot;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>                  <span class="op">,</span> play))<span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>        <span class="cf">return</span> (<span class="bu">Array</span><span class="op">.</span><span class="fu">isArray</span>(resp)) <span class="op">?</span> resp <span class="op">:</span> []<span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>    }<span class="op">,</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>    <span class="dt">give</span> <span class="op">:</span> <span class="kw">function</span> (player<span class="op">,</span>n<span class="op">,</span>hand) {</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>        <span class="kw">var</span> give <span class="op">=</span> <span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(<span class="fu">giveWorstCards</span>(n<span class="op">,</span>hand))<span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>        <span class="kw">var</span> resp <span class="op">=</span> <span class="bu">JSON</span><span class="op">.</span><span class="fu">parse</span>(</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>            <span class="fu">prompt</span>( <span class="st">&quot;Your hand is &quot;</span><span class="op">+</span>hand<span class="op">+</span><span class="st">&quot;.</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>                  <span class="op">+</span> <span class="st">&quot;What would you like to give?&quot;</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a>                  <span class="op">,</span> give))<span class="op">;</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a>        <span class="cf">return</span> (<span class="bu">Array</span><span class="op">.</span><span class="fu">isArray</span>(resp)) <span class="op">?</span> resp <span class="op">:</span> []<span class="op">;</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a>    }</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a>})<span class="op">;</span></span></code></pre></div>
<p>That’s it for now. I’ll be back later with a <em>proper</em> AI for The Great Dalmuti—though, I probably won’t be implementing it in JavaScript. If you’ve had a look under the hood, you may have noticed a bunch of completely garbled JavaScript files. This is because I’ve actually implemented the game in Haskell, and compiled it to JavaScript using <a href="https://github.com/ghcjs/ghcjs">GHCJS</a>—which is awesome! Thanks a whole bunch to the GHCJS project, helping Haskell get into the browser!</p>]]></description>
    <pubDate>Tue, 05 Apr 2016 00:00:00 UT</pubDate>
    <guid>http://wenkokke.github.io/posts/2016-04-05-presidents-scumbags-kings-and-arseholes-and-the-great-dalmuti.html</guid>
    <dc:creator>Wen Kokke</dc:creator>
</item>
<item>
    <title>Breadboxes, Plenty Questions and Distributional Semantics</title>
    <link>http://wenkokke.github.io/posts/2016-03-21-breadboxes-and-distributional-semantics.html</link>
    <description><![CDATA[<p>Quite a while ago, <a href="https://github.com/UnicornPower">UnicornPower</a> introduced me to a game called <em>Breadbox</em>. It’s an experimental cousin of <em>20 Questions</em>, also known as <em>Plenty Questions</em>, which is played by two players—or more, really—who we’ll name Allie and Blake:</p>
<ul>
<li>Allie thinks of something.</li>
<li>As their first question, Blake asks <em>“Is it a breadbox?”</em></li>
<li>Allie—who, seeing the mandatory first question, obviously wouldn’t choose a breadbox—answers <em>“No, it’s not!”</em></li>
</ul>
<p>From there on out, all Blake’s questions have to be of the form…</p>
<ul>
<li><em>“Is it more like a breadbox, or more like…?”</em></li>
</ul>
<p>…where <em>breadbox</em> is replaced by whatever the current guess is, and the dots are filled in with whatever Blake wants. Let’s see if we can write an AI for playing this game!</p>
<!--more-->
<p>Okay, before we get started, let’s look at an example of a quick game:</p>
<dl>
<dt>Allie</dt>
<dd>I’m thinking of something…
</dd>
<dt>Blake</dt>
<dd>Is it a breadbox?
</dd>
<dt>Allie</dt>
<dd>No, it’s not.
</dd>
<dt>Blake</dt>
<dd>Is it more like a breadbox or more like a dog?
</dd>
<dt>Allie</dt>
<dd>It’s more like a dog…
</dd>
<dt>Blake</dt>
<dd>Is it more like a dog or more like a cat?
</dd>
<dt>Allie</dt>
<dd>It’s more like a cat…
</dd>
<dt>Blake</dt>
<dd>Is it more like a cat or more like a unicorn?
</dd>
<dt>Allie</dt>
<dd>It’s more like a cat…
</dd>
<dt>Blake</dt>
<dd>Is it more like a cat or more like a garden?
</dd>
<dt>Allie</dt>
<dd>It’s more like a garden…
</dd>
<dt>Blake</dt>
<dd>Is it more like a garden or more like a house?
</dd>
<dt>Allie</dt>
<dd>It’s more like a house…
</dd>
<dt>Blake</dt>
<dd>Is it more like a house or more like a friend?
</dd>
<dt>Allie</dt>
<dd>It’s more like a friend…
</dd>
<dt>Blake</dt>
<dd>Is it more like a friend or more like a lover?
</dd>
<dt>Allie</dt>
<dd>It’s more like a friend…
</dd>
<dt>Blake</dt>
<dd>Is it more like a friend or more like a relative?
</dd>
<dt>Allie</dt>
<dd>It’s more like a friend…
</dd>
<dt>Blake</dt>
<dd>Is it more like a friend or more like a neighbour?
</dd>
<dt>Allie</dt>
<dd>That’s exactly what I was thinking of!
</dd>
</dl>
<p>Since this game tends to bring out the… best in people, Blake might just have to give up. After this, Allie may be called on to explain what the word she chose even means:</p>
<dl>
<dt>Blake</dt>
<dd>I give up… what was it?
</dd>
<dt>Allie</dt>
<dd>Reverberation!
</dd>
<dt>Allie</dt>
<dd>It’s the repetition of a sound resulting from reflection of the sound waves!
</dd>
</dl>
<p>The game does a <em>fantastic</em> job of revealing how hierarchical people tend to think. For instance, I would say that a dolphin is more like an orca than it is like a mammal, <em>even though a dolphin isn’t an orca</em>. But while playing the game, I often find myself slipping into hierarchical thinking: “Oh, it’s not like an animal… so we can exclude all animals.”</p>
<p>It is exactly this—the fact that the game forces you to consider a distance metric for your internal ontology, insofar as one exists—which makes it so fascinating to play. I heartily recommend you try it!</p>
<p>If you’re upset because Breadbox is hard, or because you think that the choices it makes are weird or wrong… try playing it with a person!</p>
<hr />
<blockquote>
<p><em>Hiya! It’s Wen from the future, here to tell you that I used to have a copy of Breadbox running on OpenShift, where you could try it out for yourself. Unfortunately, that died with the deprecation of OpenShift 2, and I haven’t been able to find anywhere else that would let me host a 2GB web app for free…</em><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
</blockquote>
<hr />
<p>In the summer of 2014, I took a course on distributional semantics (by Marco Baroni and Georgiana Dinu) and the first thing I thought to do was to use their [dataset][semantic-vectors] to implement an AI for Breadbox. <del>Try it here!</del></p>
<p>So how does it work? The core hypothesis of distributional semantics is</p>
<blockquote>
<p>You can know the meaning of a word by the company it keeps</p>
</blockquote>
<p>Have a look at the two sentences below:<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<ol type="1">
<li>He filled the <em>wampimuk</em>, passed it around and we all drunk some.</li>
<li>We found a little, hairy <em>wampimuk</em> sleeping behind the tree.</li>
</ol>
<p>While you’ve probably never read the word wampimuk before, it’s likely that either sentence will give you a pretty clear idea of what a wampurnik is <em>in that context</em>.</p>
<p>So if you want to know what a word (e.g. “bear”) means, you take a <em>huge</em> corpus, and you look for all the occurances of that word…<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<pre style="margin-left: 3em;">
       over the mountains. A <a style="color:dark-orange;">bear</a> also features prominentl
    rnejakt" (An Unfortunate <a style="color:dark-orange;">Bear</a> Hunt) by Theodor Kittels
       to his hagiography, a <a style="color:dark-orange;">bear</a> killed Saint Corbinian's
         however, he let the <a style="color:dark-orange;">bear</a> go. The saddled "bear
       bear go. The saddled "<a style="color:dark-orange;">bear</a> of St. Corbinian" the
    tails on this topic, see <a style="color:dark-orange;">Bear</a> in heraldry. The British
         Cat and the Russian <a style="color:dark-orange;">Bear</a> (see The Great Game)
     Great Game) The Russian <a style="color:dark-orange;">bear</a> is a common national
    Soviet Union). The brown <a style="color:dark-orange;">bear</a> is also Finland's nation
    animals and had the same <a style="color:dark-orange;">bear</a> carry him from his hermi
         thus Christianised, <a style="color:dark-orange;">bear</a> clasping each gable
     evidence of prehistoric <a style="color:dark-orange;">bear</a> worship. Anthropologists
     peoples, considered the <a style="color:dark-orange;">bear</a> as the spirit of one's
    fathers. This is why the <a style="color:dark-orange;">bear</a> (karhu) was a greatly
    ikämmen and kontio). The <a style="color:dark-orange;">bear</a> is the national animal
      tries to kill a mother <a style="color:dark-orange;">bear</a> and her cubs—and is
         society. "The Brown <a style="color:dark-orange;">Bear</a> of Norway" is a Scottish
     magically turned into a <a style="color:dark-orange;">bear</a>, and who managed to get
     television. Evidence of <a style="color:dark-orange;">bear</a> worship has been found
      mythology identify the <a style="color:dark-orange;">bear</a> as their ancestor and
    shopric of Freising, the <a style="color:dark-orange;">bear</a> is the dangerous totem
</pre>
<p>…and then you count, for every other word, how often it occurs together with your word. The above text, for instance, gives us a number of obvious co-occurances for bear: mountain, kill, hunt, brown, animal and cub. The idea is that, given a large enough corpus, these co-occurances will drown out the noisier ones.</p>
<p>By doing this for <em>every</em> word, you build up a co-occurance matrix, which lists how often every word occurs with every other word. For instance,<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: left;">leash</th>
<th style="text-align: left;">walk</th>
<th style="text-align: left;">run</th>
<th style="text-align: left;">owner</th>
<th style="text-align: left;">pet</th>
<th style="text-align: left;">bark</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>dog</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">2</td>
</tr>
<tr class="even">
<td>cat</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="odd">
<td>lion</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="even">
<td>light</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="odd">
<td>bark</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="even">
<td>car</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">0</td>
</tr>
</tbody>
</table>
<p>Now the meaning for a word is determined by its co-occurances with some select group of words. For instance, if we look at ‘dog’ we see that it strongly co-occurs with things such as ‘leash’, ‘walk’, ‘owner’, ‘pet’ and ‘bark’. For ‘cat’, we lose ‘leash’ and ‘bark’—since cats don’t bark, and are rarely leashed. And for ‘lion’, we also lose ‘owner’ and ‘pet’—while a lion could conceivably be a pet, it’d be a lot rarer than having a cat or dog… and we could never really feel like we <em>owned</em> the lion.</p>
<p>You can think of the rows in this matrix as points, in a six dimensional space—one dimension for every column. And because it’s a space, you can measure the distance between words. And this is where we get back to Breadbox: in order to play this bizarre game, we needed a distance metric for meanings, to be able to compare and order <em>any two objects</em>. And this is <em>exactly</em> what a co-occurance matrix gives us!</p>
<p>Obviously, there’s a lot more to distributional semantics than just this. For instance, the matrices that you derive this way tend to be huge—one axis per word, one point per word—so there’s a whole bunch of work which goes into selecting exactly which set of words should be the axes. Then there’s the difficultly of <em>composing</em> word meanings. You may have noticed that my breadbox implementation doesn’t work all too well for compound nouns: that’s because I’m not taking the effort to compose meaning vectors.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<p>If you wish to read more about distributional semantics, there’s a pretty good overview of introductions and surveys [here][slides]. Additionally, there’s a whole branch of work which uses neural networks to learn the word meanings: for instance, have a look at [Word2Vec][word2vec].</p>
<hr />
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>You can still try to run it [from source][breadbox], but be warned… I did not future-proof it. [DontCountPredict]: http://clic.cimec.unitn.it/marco/publications/acl2014/baroni-etal-countpredict-acl2014.pdf [word2vec]: http://deeplearning4j.org/word2vec [slides]: https://www.cs.utexas.edu/~mooney/cs388/slides/dist-sem-intro-NLP-class-UT.pdf [semantic-vectors]: http://clic.cimec.unitn.it/composes/semantic-vectors.html [breadbox]: https://github.com/wenkokke/Breadbox<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Taken from <a href="https://www.cs.utexas.edu/~mooney/cs388/slides/dist-sem-intro-NLP-class-UT.pdf" class="uri">https://www.cs.utexas.edu/~mooney/cs388/slides/dist-sem-intro-NLP-class-UT.pdf</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Taken from <a href="http://www.webcorp.org.uk" class="uri">http://www.webcorp.org.uk</a>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>Taken from <a href="https://www.cs.utexas.edu/~mooney/cs388/slides/dist-sem-intro-NLP-class-UT.pdf" class="uri">https://www.cs.utexas.edu/~mooney/cs388/slides/dist-sem-intro-NLP-class-UT.pdf</a>.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>A bit of a shame, really, since the course I took was <em>about</em> composing meaning vectors. Also, full disclosure, the vectors that I used were created using [Word2Vec][word2vec], using neural networks. Such vectors generally outperform counting vectors in tasks of relatedness (see <em>[Don’t Count, Predict!][DontCountPredict]</em> by Baroni et al.).<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></description>
    <pubDate>Mon, 21 Mar 2016 12:00:00 UT</pubDate>
    <guid>http://wenkokke.github.io/posts/2016-03-21-breadboxes-and-distributional-semantics.html</guid>
    <dc:creator>Wen Kokke</dc:creator>
</item>
<item>
    <title>Constraint Grammar can count!</title>
    <link>http://wenkokke.github.io/posts/2016-03-16-constraint-grammar-can-count.html</link>
    <description><![CDATA[<p>Constraint grammar—it is a natural language processing formalism with great two distinctions: it routinely scores amongst the highest in tasks such as part-of-speech tagging and word-sense disambiguation, with F-scores at around 99%; and it has made some of the most dubious choices in programming language syntax in history. Though its specification has changed tremendously since CG1, it is nontheless a grammar formalism which sees a lot of usage. One natural question to ask of any grammar formalism is “how expressive is it?”</p>
<p>Over the weekend, <a href="https://github.com/inariksit">inariksit</a> visited me, and we decided to find out!</p>
<!--more-->
<p>It’s not immediately obvious how to even approach this question, as constraint grammar doesn’t <em>generate</em> strings per se. It simply <em>constrains</em> existing, ambiguous strings. We took the following approach: we view a constraint grammar as a formal language <span class="math inline">ℒ</span>, generated over an alphabet <span class="math inline"><em>Σ</em></span>. We generate the strings in our language by passing maximally ambiguous strings of <em>every</em> length to the grammar. With maximally ambiguous, I mean those strings where each position contains the entire alphabet, so <span class="math inline">⟨<em>Σ</em>⟩<sub><em>n</em></sub></span>. A constraint grammar is said to <em>accept</em> a string <span class="math inline"><em>w</em></span> of length <span class="math inline"><em>n</em></span> if, when we pass <span class="math inline">⟨<em>Σ</em>⟩<sub><em>n</em></sub></span> as an input to the CG, <span class="math inline"><em>w</em></span> is one of the possible interpretations of its output.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>The specification of CG3 mentions tags such as <code>EXTERNAL</code>, which passes information to an external command. So constraint grammar is obviously Turing complete. However, that’s a little bit boring, so let’s see what we can say about the expressiveness of the absolute core of constraint grammar: <code>REMOVE</code> with sections. If we leave out sections, there is no recursion, and therefore the language will be strictly finite and boring. If we leave out <code>REMOVE</code> then there is no way to restrict strings, so we’d only have the languages <span class="math inline"><em>Σ</em><sup>*</sup></span> for any <span class="math inline"><em>Σ</em></span>.</p>
<p>There are a few concessions we will allow ourselves. If we had <code>MAP</code>, <code>ADD</code>, or any such other command, we would have a way to store information. In this strict fragment, all we have is the current set of symbol assignments. Therefore, we will allow ourselves a second alphabet <span class="math inline"><em>Σ</em>′</span> of <em>hidden</em> symbols—i.e. symbols that we are not allowed to pass to the output. In addition, we update our definition of <span class="math inline">ℒ</span> to state that we pass in <span class="math inline">⟨<em>Σ</em> ∪ <em>Σ</em>′⟩<sub><em>n</em></sub></span>. This is not <em>strictly</em> necessary in CG3, as we could use <code>APPEND</code> to add these hidden characters, but we would like to stay as faithful to our fragment as possible.</p>
<p>One last hurdle is that constraint grammar has no notion of <em>failure</em>. The worst that can happen is that a grammar changes nothing. Worse so, if there is only one reading left, the <code>REMOVE</code> command will have no effect. So one more concession we make is that we allow ourselves to use the <code>REMCOHORT</code> command—which removes an entire “cohort”, or “position” in our terminology—for the <em>sole purpose</em> of deleting the entire string if it is not accepted.</p>
<p>From here on out, when we say ‘CG3’, we are referring to this fragment of constraint grammar.</p>
<h3 id="cg3-is-not-regular-the-language-anbn">CG3 is not regular; the language <span class="math inline"><em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup></span></h3>
<p>In this section we show that CG3, restricted to sections and <code>REMOVE</code> is not regular. We show this by implementing a grammar for the counting language <span class="math inline"><em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup></span>.</p>
<p>The first thing we do is to try and detect the edges of the string. CG3 has “magical” constants for this, called <code>&gt;&gt;&gt;</code> and <code>&lt;&lt;&lt;</code> for the left and right edge, respectively. However, we cannot use those. Instead, we define them ourselves using two hidden variables, which we also call <code>&gt;&gt;&gt;</code> and <code>&lt;&lt;&lt;</code>. We do this as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>SET ANY <span class="op">=</span> A OR B<span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>BEFORE<span class="op">-</span>SECTIONS</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>REMOVE <span class="op">&gt;&gt;&gt;</span> (<span class="op">-</span><span class="dv">1</span> ANY)<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>REMOVE <span class="op">&lt;&lt;&lt;</span> ( <span class="dv">1</span> ANY)<span class="op">;</span></span></code></pre></div>
<p>Initially, all positions will be labeled with both <code>&gt;&gt;&gt;</code> and <code>&lt;&lt;&lt;</code>. These above rules check whether there is <em>any</em> position preceding or succeeding the current position, and if so, delete <code>&gt;&gt;&gt;</code> or <code>&lt;&lt;&lt;</code>. As a result, the first position will be the only one tagged <code>&gt;&gt;&gt;</code>, and the last the only one tagged <code>&lt;&lt;&lt;</code>.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>Next, we note that <em>all</em> strings in the language <span class="math inline"><em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup></span> are of even length, and that every even length corresponds to <em>exactly</em> one string. Therefore, we must reject all strings of uneven length. We assume two more hidden symbols, <code>EVEN</code> and <code>ODD</code>. We can use these to label whether a position is even or odd: we know the first position is odd, so we delete <code>EVEN</code>; we know that positions following odd positions must be even, so we delete <code>ODD</code>; and we know that positions following even positions are <code>ODD</code>, so we delete <code>EVEN</code>…<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>BEFORE<span class="op">-</span>SECTIONS</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>REMOVE EVEN (<span class="dv">0</span> <span class="op">&gt;&gt;&gt;</span>)<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>SECTION</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>REMOVE ODD  (NOT  <span class="dv">0</span> <span class="op">&gt;&gt;&gt;</span> LINK NOT <span class="op">-</span><span class="dv">1</span> EVEN)<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>REMOVE EVEN (NOT <span class="op">-</span><span class="dv">1</span> ODD)<span class="op">;</span></span></code></pre></div>
<p>It’s exactly this “marking as even by deleting odd” that makes it a bit of a confusing read, so if you’d like to play around with an example, <a href="https://gist.github.com/wenkokke/e5f76d82939ecc9d3a4c">my full code with examples is available here</a>, and <a href="http://beta.visl.sdu.dk/cg3/chunked/installation.html">vislcg3 is available here</a>.</p>
<p>Anyway, after performing this labelling, we can check if the last position is even, and if so, delete all positions:<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>AFTER<span class="op">-</span>SECTIONS</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>REMCOHORT ANY (<span class="dv">1</span><span class="op">*</span> <span class="op">&lt;&lt;&lt;</span> LINK NOT <span class="dv">0</span> EVEN)<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>REMCOHORT <span class="op">&lt;&lt;&lt;</span> (NOT <span class="dv">0</span> EVEN)<span class="op">;</span></span></code></pre></div>
<p>Now that we are certain that we only accept even-length strings, it is safe to say that the first symbol must be an <span class="math inline"><em>a</em></span>, and the last must be a <span class="math inline"><em>b</em></span>:<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>BEFORE<span class="op">-</span>SECTIONS</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>SELECT A (<span class="dv">0</span> <span class="op">&gt;&gt;&gt;</span>)<span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>SELECT B (<span class="dv">0</span> <span class="op">&lt;&lt;&lt;</span>)<span class="op">;</span></span></code></pre></div>
<p>And now it’s only a matter of slowly growing these <span class="math inline"><em>a</em></span>s and <span class="math inline"><em>b</em></span>s until they meet. We do this as follows: in each pass, we mark the position <em>after</em> the last definite <span class="math inline"><em>a</em></span> as a candidate for <span class="math inline"><em>a</em></span> (written <code>OPT_A</code>), and do likewise for the last position <em>before</em> the first definite <span class="math inline"><em>b</em></span>. Then we mark each candidate <span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span> as <em>definite</em>, and we continue:<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>SECTION</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>REMOVE OPT_B (<span class="op">-</span>1C A)<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>REMOVE OPT_A ( 1C B)<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>SELECT A (NOT <span class="dv">0</span> OPT_B)<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>SELECT B (NOT <span class="dv">0</span> OPT_A)<span class="op">;</span></span></code></pre></div>
<p>The grammar described so far exactly expresses the language <span class="math inline"><em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup></span>.<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> Since this language is not regular, we can conclude that constraint grammar is not regular.</p>
<h3 id="cg3-is-not-context-free-the-language-anbncn">CG3 is not context-free; the language <span class="math inline"><em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup><em>c</em><sup><em>n</em></sup></span></h3>
<p>In this section we show that CG3, restricted to sections and <code>REMOVE</code> is not context-free. We show this by implementing a grammar for the counting language <span class="math inline"><em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup><em>c</em><sup><em>n</em></sup></span>.</p>
<p>The language <span class="math inline"><em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup><em>c</em><sup><em>n</em></sup></span> has us divide strings whose length is a multiple of three into three even chunks. The first part of this is obviously to find the bounds of the input string, as before, and make sure that it has a length divisible by three. We can trivially extend our previous approach—now abandoning “even” and “odd” in favour of <code>X1</code>, <code>X2</code> and <code>X3</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>SET X1_OR_X2 <span class="op">=</span> X1 OR X2<span class="op">;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>SET X2_OR_X3 <span class="op">=</span> X2 OR X3<span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>SET X3_OR_X1 <span class="op">=</span> X3 OR X1<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>BEFORE<span class="op">-</span>SECTIONS</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>REMOVE X2_OR_X3 (<span class="dv">0</span> <span class="op">&gt;&gt;&gt;</span>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>SECTION</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>REMOVE X3_OR_X1 (NOT <span class="dv">0</span> <span class="op">&gt;&gt;&gt;</span> LINK NOT <span class="op">-</span><span class="dv">1</span> X2_OR_X3)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>REMOVE X1_OR_X2 (NOT <span class="dv">0</span> <span class="op">&gt;&gt;&gt;</span> LINK NOT <span class="op">-</span><span class="dv">1</span> X3_OR_X1)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>REMOVE X2_OR_X3 (NOT <span class="dv">0</span> <span class="op">&gt;&gt;&gt;</span> LINK NOT <span class="op">-</span><span class="dv">1</span> X1_OR_X2)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>AFTER<span class="op">-</span>SECTIONS</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>REMCOHORT ANY (<span class="dv">1</span><span class="op">*</span> <span class="op">&lt;&lt;&lt;</span> LINK NOT <span class="dv">0</span> X3)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>REMCOHORT <span class="op">&lt;&lt;&lt;</span> (NOT <span class="dv">0</span> X3)</span></code></pre></div>
<p>Note that, somewhat counterintuitively, <code>REMOVE X1_OR_X2</code><a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> removes <em>both</em> <code>X1</code> and <code>X2</code>, but <code>0 X1_OR_X2</code> matches if the current position still has either option.</p>
<p>Now that we can be sure that our string is of some length <span class="math inline">3<em>n</em></span>, we can proceed to divide it into three equal chunks. One good way to do this, is to start by finding the middle. This is <em>exactly</em> what we did in our grammar for <span class="math inline"><em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup></span>. Below we implement the same, but now <em>without</em> using <code>SELECT</code>, as using this would erase all other tags. For this, we assume four new hidden symbols <code>FST</code>, <code>SND</code>—for first and second half—and <code>OPT_*</code> varieties:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>SET NOT_FST <span class="op">=</span> OPT_FST OR SND OR OPT_SND <span class="op">;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>SET NOT_SND <span class="op">=</span> FST OR OPT_FST OR OPT_SND <span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>BEFORE<span class="op">-</span>SECTIONS</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>REMOVE NOT_FST (<span class="dv">0</span> <span class="op">&gt;&gt;&gt;</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>REMOVE NOT_SND (<span class="dv">0</span> <span class="op">&lt;&lt;&lt;</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>SECTION</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>REMOVE OPT_SND (<span class="op">-</span><span class="dv">1</span> FST LINK (NOT <span class="dv">0</span> NOT_FST))</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>REMOVE OPT_FST ( <span class="dv">1</span> SND LINK (NOT <span class="dv">0</span> NOT_SND))</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>REMOVE NOT_FST (<span class="dv">0</span> FST LINK <span class="dv">0</span> SND LINK <span class="dv">0</span> OPT_FST LINK NOT <span class="dv">0</span> OPT_SND)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>REMOVE NOT_SND (<span class="dv">0</span> FST LINK <span class="dv">0</span> SND LINK <span class="dv">0</span> OPT_SND LINK NOT <span class="dv">0</span> OPT_FST)</span></code></pre></div>
<p>Once we’ve divided the word in half, it becomes fairly easy to point out the middle. Below, we mark the first position as <span class="math inline"><em>a</em></span>, the last position as <span class="math inline"><em>c</em></span> and the middle position as <span class="math inline"><em>b</em></span>:<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>SET OPT_A_OR_B <span class="op">=</span> (OPT_A OR OPT_B)<span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>SET OPT_B_OR_C <span class="op">=</span> (OPT_A OR OPT_B)<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>SET OPT_C_OR_D <span class="op">=</span> (OPT_A OR OPT_B)<span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>BEFORE<span class="op">-</span>SECTIONS</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>REMOVE OPT_B_OR_C (<span class="dv">0</span> <span class="op">&gt;&gt;&gt;</span>)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>REMOVE OPT_A_OR_B (<span class="dv">0</span> <span class="op">&lt;&lt;&lt;</span>)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>SECTION</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>REMOVE OPT_C_OR_A (<span class="dv">0</span> FST LINK  <span class="dv">1</span> SND LINK NOT <span class="dv">0</span> FST)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>REMOVE OPT_C_OR_A (<span class="dv">0</span> SND LINK <span class="op">-</span><span class="dv">1</span> FST LINK NOT <span class="dv">0</span> SND)</span></code></pre></div>
<p>And finally, we grow <span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span>, and <span class="math inline"><em>b</em></span> and <span class="math inline"><em>c</em></span> towards one another as we did before. Note that we have to let <span class="math inline"><em>a</em></span> and <span class="math inline"><em>c</em></span> grow twice every time we grow <span class="math inline"><em>b</em></span>, because <span class="math inline"><em>b</em></span> is growing in <em>two</em> directions at the same time:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>SECTION</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>REMOVE OPT_B_OR_C (<span class="op">-</span>1C A)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>REMOVE OPT_A_OR_B ( 1C C)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>SELECT A (<span class="dv">0</span> OPT_A LINK NOT <span class="dv">0</span> OPT_B_OR_C)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>SELECT C (<span class="dv">0</span> OPT_C LINK NOT <span class="dv">0</span> OPT_A_OR_B)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>REMOVE OPT_C_OR_A ( 1C B)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>REMOVE OPT_C_OR_A (<span class="op">-</span>1C B)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>SELECT B (<span class="dv">0</span> OPT_B LINK NOT <span class="dv">0</span> OPT_C_OR_A)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>REMOVE OPT_B_OR_C (<span class="op">-</span>1C A)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>REMOVE OPT_A_OR_B ( 1C C)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a>SELECT A (<span class="dv">0</span> OPT_A LINK NOT <span class="dv">0</span> OPT_B_OR_C)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a>SELECT C (<span class="dv">0</span> OPT_C LINK NOT <span class="dv">0</span> OPT_A_OR_B)</span></code></pre></div>
<p>The grammar described so far exactly expresses the language <span class="math inline"><em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup><em>c</em><sup><em>n</em></sup></span>. Since this language is not context-free, we can conclude that constraint grammar is not context-free.</p>
<h3 id="beyond-context-free">Beyond Context-Free</h3>
<p>It seems pretty obvious that a language formalism whose only construct has the power to observe <em>all</em> of its surrounding context ends up being at least context-sensitive. I could continue. It is still fairly straightforward to generate the language <span class="math inline"><em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup><em>c</em><sup><em>n</em></sup><em>d</em><sup><em>n</em></sup></span>—divide into half, and divide halves into half—and using similar strategies, you can keep on constructing CGs which compute the counting language <span class="math inline"><em>σ</em><sub>1</sub><sup><em>n</em></sup>⋯<em>σ</em><sub><em>k</em></sub><sup><em>n</em></sup></span> for any <span class="math inline"><em>k</em></span> as long as you can come up with new strategies for prime numbers.. but this won’t do us a whole lot of good—at least, it won’t help us escape the class of context-sensitive languages.</p>
<p>So for now, let’s leave it at this. I’m a little bored of programming CG at any rate. If you want to have a go, <a href="https://gist.github.com/wenkokke/e5f76d82939ecc9d3a4c">my full code and examples are available here</a>, and <a href="http://beta.visl.sdu.dk/cg3/chunked/installation.html">vislcg3 is available here</a>.</p>
<hr />
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>An obvious downside to this approach is that for finite languages (as well as infinite ones, but duh) the CG will never stop generating the language, as we have to feed it <span class="math inline">⟨<em>Σ</em>⟩<sub><em>n</em></sub></span> <em>for every <span class="math inline"><em>n</em></span></em>. But we’re playing fast and loose here, so what gives.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>CG3’s magic constants are just outside of the string, whereas ours are right at the edge of the string. Therefore, all indices using magic constants are moved by one.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>While we use <code>BEFORE-SECTIONS</code> and <code>AFTER-SECTIONS</code> throughout this post, their usage is not strictly necessary. The grammar also works if everything is executed under a single <code>SECTION</code>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>Note that <code>LINK</code> is a conjunction, but one in which indices in the <em>second</em> argument are interpreted from the perspective of the position matched in the first.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>We have chosen to describe faillure by outputting the empty string. If we would have been more careful, we could have added a dedicated symbol for failure. However, under our current definitions we compare languages <em>minus</em> the empty string.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>We can use <code>SELECT</code>, since it is equivalent to calling <code>REMOVE</code> with the complement—i.e. remove everything <em>but</em> its argument.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>Note that <code>SELECT A</code> has no effect if <span class="math inline"><em>a</em></span> is not a valid option, and that <code>REMOVE A</code> has no effect if <span class="math inline"><em>a</em></span> is the <em>only</em> remaining option.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>We have chosen to describe faillure by outputting the empty string. If we would have been more careful, we could have added a dedicated symbol for failure. However, under our current definitions we compare languages <em>minus</em> the empty string.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>When we write <code>X_OR_Y</code>, this means that we have defined a “set” as <code>SET X1_OR_X2 = X1 OR X2;</code>. The reason for this is that CG3 does not allow the <em>inline</em> use of set primitives.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p>If the string has an even-numbered length, we in fact mark the middle <em>two</em> positions as <span class="math inline"><em>b</em></span>.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></description>
    <pubDate>Wed, 16 Mar 2016 12:00:00 UT</pubDate>
    <guid>http://wenkokke.github.io/posts/2016-03-16-constraint-grammar-can-count.html</guid>
    <dc:creator>Wen Kokke</dc:creator>
</item>
<item>
    <title>Side-effects in English</title>
    <link>http://wenkokke.github.io/posts/2016-03-09-side-effects-in-english.html</link>
    <description><![CDATA[<p>Back when I wrote this, I had just discovered <a href="http://okmij.org/ftp/Haskell/extensible/">“Extensible Effects: an alternative to Monad Transformers”</a> by Oleg Kiselyov, Amr Sabry, Cameron Swords, and Hiromi Ishii, and I’ve always had a penchant for mucking about with linguistics and Haskell… so… let’s have a little fun with this library and some basic AB grammars in Haskell, see how far we can get within the universally well-defined maximum length of a blog post!</p>
<!--more-->
<p>Before we start, let’s get a clear idea of what we’re going to try and accomplish. It’s more or less a well known fact that natural language has tons of side-effects—sometimes also referred to as “non-compositional phenomena”. Let’s look at some examples:</p>
<ol type="1">
<li>“I cooked up a delicious dinner!”</li>
<li>“There! I walked the damn dog!”</li>
<li>“As Mary left, she whistled a cheery tune.”</li>
</ol>
<p>In (1), the word “I” is non-compositional: it’s a word which you can always use, but which changes its meaning depending on the context—on who uses it. In (2) we have the word “damn”, an expressive. There’s pretty extensive literature on expressives—see, for instance, Daniel Gutzmann’s <a href="http://www.danielgutzmann.com/work/use-conditional-meaning">“Use-conditional meaning”</a>—but the gist of it is as follows: “damn” doesn’t affect the <em>truth</em> of a sentence. If I come back from walking the dog, even though I do not like dogs, and say “There! I walked the damn dog!”, you can’t reply by saying “No, you didn’t! The dog is nice!” Instead, “damn” conveys it’s meaning on some sort of side-channel. Finally, in (3) we have “she”, which again has a context-dependent meaning. However, in this situation, “she” doesn’t get its meaning from the context in which the sentence is uttered. Instead, reading this sentence in isolation, it seems pretty likely that “she” refers to Mary.</p>
<p>“Non-compositional phenomena” is a bit of a misnomer for the phenomena in (1-3). We can implement these phenomena as <em>side-effects</em>, and as we know from functional programming, side-effects are often perfectly compositional. In fact, the above phenomena correspond, in Haskell-lingo, to a <em>Reader</em>, a <em>Writer</em> and a <em>State</em> monad.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> However, rolling together various different monads can be a tedious chore. In addition, when we’re writing what a word means, we might not <em>want</em> to specify its meaning for <em>all possible side-effects</em>. Since linguistics is continually changing, we might not even want to commit to what all possible side-effects <em>are</em>.</p>
<p>So this is why I got excited when I saw the latest library for extensible effects. If you don’t know what extensible effects are, I’d recommend <a href="http://okmij.org/ftp/Haskell/extensible/">the paper linked above</a>. But anyway, what I’m going to do in this post is: develop a parser, which parses Haskell strings, looks up the words in a dictionary of <em>effectful</em> Haskell functions, and composes these to get some meaning for the sentence. Here’s an example that you’ll see again at the end of the post, except then it’ll actually work!</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">lex</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">SomeEffectfulFunction</span>]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">lex</span> <span class="st">&quot;tim&quot;</span>    <span class="ot">=</span> [ <span class="dt">NP</span> , <span class="dt">Tim</span>             ]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="fu">lex</span> <span class="st">&quot;bob&quot;</span>    <span class="ot">=</span> [ <span class="dt">NP</span> , <span class="dt">Bob</span>             ]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="fu">lex</span> <span class="st">&quot;likes&quot;</span>  <span class="ot">=</span> [ <span class="dt">TV</span> , <span class="dt">Like</span>            ]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="fu">lex</span> <span class="st">&quot;stupid&quot;</span> <span class="ot">=</span> [ <span class="dt">AP</span> , <span class="op">&lt;</span> <span class="fu">id</span> , <span class="dt">Stupid</span> <span class="op">&gt;</span> ]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>  <span class="co">-- ^ Has an identity (i.e. no) meaning, but</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>  <span class="co">--   but conveys `Stupid` as a side-effect.</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="fu">lex</span> <span class="st">&quot;him&quot;</span>    <span class="ot">=</span> [ <span class="dt">NP</span> , magic           ]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>  <span class="co">-- ^ Has some magic way of obtaining the</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>  <span class="co">--   thing that&#39;s referenced.</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a><span class="ot">example ::</span> [(<span class="dt">Pred</span>, [<span class="dt">Pred</span>])]</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>example <span class="ot">=</span> parseWith <span class="dt">Tim</span> <span class="st">&quot;(stupid bob) likes him&quot;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>  <span class="co">-- &gt; [(Like Bob Tim, [Stupid Bob])]</span></span></code></pre></div>
<h2 id="ab-grammars-in-haskell">AB Grammars in Haskell</h2>
<p>Well, first off, don’t let this scare you off… but we are going to do this in Haskell, and we’re going to need a LOT of language extensions. This is because we’re basically going to parse strings to Haskell functions:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ot">{-# LANGUAGE</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="ot">    TemplateHaskell, QuasiQuotes, FlexibleInstances, </span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="ot">    FlexibleContexts, TypeFamilies, GADTs, TypeOperators, </span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="ot">    DataKinds, PolyKinds, RankNTypes, KindSignatures, </span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="ot">    UndecidableInstances, StandaloneDeriving, RecordWildCards, </span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="ot">    DeriveFunctor, DeriveFoldable, DeriveTraversable #-}</span></span></code></pre></div>
<!--
```haskell
import Prelude hiding (lookup,lex)
import Control.Applicative ((<|>),empty,liftA2)
import Data.Maybe (maybeToList)
import Data.Singletons.Decide (Decision(..),(:~:)(..),(%~))
import Data.Singletons.Prelude
import Data.Singletons.TH (singletons)
import Eff1 (Eff,run,Reader,runReader,ask,Writer,tell,runWriter)
import Text.Parsec (char,letter,spaces,many1,chainr1,parse)
```
-->
<p>In addition, we’re going to use the following packages:</p>
<ul>
<li><a href="https://hackage.haskell.org/package/singletons">singletons</a>;</li>
<li><a href="http://okmij.org/ftp/Haskell/extensible/">extensible effects</a>;</li>
<li><a href="https://hackage.haskell.org/package/parsec">parsec</a>;</li>
<li><a href="https://hackage.haskell.org/package/markdown-unlit">markdown-unlit</a>.</li>
</ul>
<p>I’ve included a copy the extensible effects code in <a href="https://github.com/wenkokke/side-effects-in-english/">the repository</a>.</p>
<p>Before we start off, let’s review some basic AB-grammar knowledge. In general, a categorial grammar—of which AB-grammars are an instance—consist of three things:</p>
<ol type="1">
<li>a typed language <span class="math inline">ℒ<sub>1</sub></span>;</li>
<li>a typed language <span class="math inline">ℒ<sub>2</sub></span>; and</li>
<li>a translation <span class="math inline"><em>T</em><em>r</em></span> from <span class="math inline">ℒ<sub>1</sub></span> to <span class="math inline">ℒ<sub>2</sub></span>.</li>
</ol>
<p>The language <span class="math inline">ℒ<sub>1</sub></span> describes the <em>grammar</em> of our language, whereas <span class="math inline">ℒ<sub>2</sub></span> will describe its <em>meaning</em>. And one more important requirement: if we have a type in <span class="math inline">ℒ<sub>1</sub></span>, then we should have some efficient way of getting all the programs of that type—this will be our parsing algorithm.</p>
<p>In the case of AB-grammars, <span class="math inline">ℒ<sub>1</sub></span> has the following types:</p>
<p><br /><span class="math display">Type <em>A</em>, <em>B</em> ≔ <em>S</em> ∣ <em>N</em> ∣ <em>N</em><em>P</em> ∣ <em>A</em> ∖ <em>B</em> ∣ <em>B</em>/<em>A</em></span><br /></p>
<p>The programs in this language consist of a bunch of constants, which represent words. It also has two rules for building programs, of them variants of function application:</p>
<p><br /><span class="math display">$$
\frac{x:A \quad f:A \backslash B}{(fx):B}{\small \backslash e}\quad\frac{f:B / A \quad x:A}{(fx):B}{\small / e}
$$</span><br /></p>
<p>The language <span class="math inline">ℒ<sub>2</sub></span> is the simply-typed lambda calculus, typed with only the primitive types <span class="math inline"><em>e</em></span> and <span class="math inline"><em>t</em></span>, for entities and truth-values:</p>
<p><br /><span class="math display">Type <em>σ</em>, <em>τ</em> ≔ <em>e</em> ∣ <em>t</em> ∣ <em>σ</em> → <em>τ</em></span><br /></p>
<p>It also has a set of typed constants, which we use to represent the abstract meanings of words. This means it contains familiar logical operators, like <span class="math inline"> ∧  : <em>t</em> → <em>t</em> → <em>t</em></span> or <span class="math inline">∀ : (<em>e</em> → <em>t</em>) → <em>t</em></span>, but also things like <span class="math inline">cat : <em>e</em> → <em>t</em></span>, the predicate which tests whether or not something is a cat.</p>
<p>The translation function then maps the types for <span class="math inline">ℒ<sub>1</sub></span> to types for <span class="math inline">ℒ<sub>2</sub></span>, and the words in <span class="math inline">ℒ<sub>1</sub></span> to expressions in <span class="math inline">ℒ<sub>2</sub></span>. For the types, the translation is as follows:</p>
<p><br /><span class="math display">$$
  \begin{array}{lcl}
    Tr(S) &amp;= &amp;t\\
    Tr(N) &amp;= &amp;e\to t\\
    Tr(NP) &amp;= &amp;e\\
    Tr(A \backslash B) &amp;= &amp;Tr(A)\to Tr(B)\\
    Tr(B / A) &amp;= &amp;Tr(A)\to Tr(B)
  \end{array}
$$</span><br /></p>
<p>The translation on the level of programs is simple: programs in <span class="math inline">ℒ<sub>1</sub></span> consist <em>solely</em> of function applications and some constants. As long as we don’t make promises in the types of those constants that we cannot keep, we should be fine!</p>
<p>So, let’s start off by creating some Haskell data types to represent the syntactic and semantic types described above:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>singletons [d|</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    data SynT = S | N | NP | SynT :\ SynT | SynT :/ SynT</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>              deriving (Show,Eq)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>    data SemT = E | T | SemT :-&gt; SemT</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>              deriving (Show,Eq)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>  |]</span></code></pre></div>
<p>The <code>singletons</code> function that we’re using here is important. It’s a template Haskell function which, given some datatype, defines its “singleton”. A “singleton” is a Haskell data type which has the same structure on the value level and on the type level. For the type <code>SynT</code> above, that means that the <code>singletons</code> function generates a second data type:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">SSynT</span> (<span class="ot">ty ::</span> <span class="dt">SynT</span>) <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  <span class="dt">SS</span><span class="ot">    ::</span> <span class="dt">SSynT</span> <span class="dt">S</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  <span class="dt">SN</span><span class="ot">    ::</span> <span class="dt">SSynT</span> <span class="dt">N</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>  <span class="dt">SNP</span><span class="ot">   ::</span> <span class="dt">SSynT</span> <span class="dt">NP</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>  (<span class="op">:%</span>\)<span class="ot"> ::</span> <span class="dt">SSynT</span> a <span class="ot">-&gt;</span> <span class="dt">SSynT</span> b <span class="ot">-&gt;</span> <span class="dt">SSynT</span> (a <span class="op">:</span>\ b)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a><span class="ot">  (:%/) ::</span> <span class="dt">SSynT</span> b <span class="ot">-&gt;</span> <span class="dt">SSynT</span> a <span class="ot">-&gt;</span> <span class="dt">SSynT</span> (b <span class="op">:/</span> a)</span></code></pre></div>
<p>By using the singleton of some value, we can get that value <em>on the type level</em>—and by pattern matching on a singleton, we can pattern match on types! For now, just be aware that those data types are generated. They will become relevant soon enough.</p>
<p>First off, though—we probably should’ve done this right away—let’s just set some fixities for our type-level operators:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="op">:</span>\</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="kw">infixl</span> <span class="dv">5</span> <span class="op">:/</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="op">:-&gt;</span></span></code></pre></div>
<p>And while we’re at it, let’s create some type-level aliases for common parts of speech—though I cannot say that this treatment of appositive modifiers is entirely common:<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">IV</span> <span class="ot">=</span> <span class="dt">NP</span> <span class="op">:</span>\ <span class="dt">S</span>  <span class="co">-- intransitive verbs</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">TV</span> <span class="ot">=</span> <span class="dt">IV</span> <span class="op">:/</span> <span class="dt">NP</span> <span class="co">-- transitive verbs</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">AP</span> <span class="ot">=</span> <span class="dt">NP</span> <span class="op">:/</span> <span class="dt">NP</span> <span class="co">-- appositive modifier</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>sIV <span class="ot">=</span> <span class="dt">SNP</span> <span class="op">:%</span>\ <span class="dt">SS</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>sTV <span class="ot">=</span> sIV <span class="op">:%/</span> <span class="dt">SNP</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>sAP <span class="ot">=</span> <span class="dt">SNP</span> <span class="op">:%/</span> <span class="dt">SNP</span></span></code></pre></div>
<p>So now that we’ve defined the types of the languages <span class="math inline">ℒ<sub>1</sub></span> and <span class="math inline">ℒ<sub>2</sub></span>, we can define our translation <em>on types</em>. Note that our previous definition of our translation function was already more-or-less valid Haskell:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Tr</span> (<span class="ot">ty ::</span> <span class="dt">SynT</span>)<span class="ot"> ::</span> <span class="dt">SemT</span> <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>  <span class="dt">Tr</span> <span class="dt">S</span>        <span class="ot">=</span> <span class="dt">T</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>  <span class="dt">Tr</span> <span class="dt">N</span>        <span class="ot">=</span> <span class="dt">E</span> <span class="op">:-&gt;</span> <span class="dt">T</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>  <span class="dt">Tr</span> <span class="dt">NP</span>       <span class="ot">=</span> <span class="dt">E</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>  <span class="dt">Tr</span> (a <span class="op">:</span>\ b) <span class="ot">=</span> <span class="dt">Tr</span> a <span class="op">:-&gt;</span> <span class="dt">Tr</span> b</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>  <span class="dt">Tr</span> (b <span class="op">:/</span> a) <span class="ot">=</span> <span class="dt">Tr</span> a <span class="op">:-&gt;</span> <span class="dt">Tr</span> b</span></code></pre></div>
<p>Let’s assume for now that we have some sort of data type that we wish to use to represent our semantic terms, for instance:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span> (<span class="ot">ty ::</span> <span class="dt">SemT</span>) <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>  <span class="dt">John</span><span class="ot"> ::</span> <span class="dt">Expr</span> <span class="dt">E</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  <span class="dt">Mary</span><span class="ot"> ::</span> <span class="dt">Expr</span> <span class="dt">E</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>  <span class="dt">Like</span><span class="ot"> ::</span> <span class="dt">Expr</span> (<span class="dt">E</span> <span class="op">:-&gt;</span> <span class="dt">E</span> <span class="op">:-&gt;</span> <span class="dt">T</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a><span class="ot">  (:$) ::</span> <span class="dt">Expr</span> (a <span class="op">:-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> b</span></code></pre></div>
<p>While we have a way of talking about terms of a certain type—e.g. by saying <code>Expr E</code> we can talk about all entities—we cannot really leave the type open and talk about <em>all</em> well-typed terms, regardless of type. For this we need to introduce a new data type:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Typed</span> (<span class="ot">expr ::</span> <span class="dt">SemT</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Typed</span> (<span class="dt">SSynT</span> a, expr (<span class="dt">Tr</span> a))</span></code></pre></div>
<p>The <code>Typed</code> data-type contains a tuple of a singleton for a semantic type, and an expression. Notice that the type-level variable <code>a</code> is shared between the singleton and the expression, which means that the expression in the second position is forced to be of the type given in the first.</p>
<p>Our definition of <code>Typed</code> has one type-level parameter, <code>expr</code>, which represents the type of expressions. One possible value for this is the <code>Expr</code> type we sketched earlier—for instance, some values of the type <code>Typed Expr</code> would be <code>(SE, John)</code>, <code>(SE, Mary)</code>, <code>(ST, Like :$ John :$ Mary)</code> and <code>(SE %:-&gt; ST, Like :$ Mary)</code>.</p>
<p>We are abstracting over the expressions used, but we’re going to need them to support <em>at least</em> function application—as this is what AB grammars are built around. Therefore, we’re going to make a tiny type class which encodes function application of functions using the semantic types:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">SemE</span> (<span class="ot">expr ::</span> <span class="dt">SemT</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="ot">    apply ::</span> <span class="kw">forall</span> a b<span class="op">.</span> expr (a <span class="op">:-&gt;</span> b) <span class="ot">-&gt;</span> expr a <span class="ot">-&gt;</span> expr b</span></code></pre></div>
<p>Using this <code>apply</code> function, we can define application on <code>Typed</code> expression as well.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> Since these expressions hide their type, we cannot enforce on the type-level that this application necessarily succeeds. What we’re doing in the function is the following:</p>
<ol type="1">
<li>we pattern match to check if either the left or the right type is an appropriate function type;</li>
<li>we use the type-level equality function <code>%~</code> to check if the argument type is the same in both cases; and</li>
<li>if so, we apply <code>apply</code>.</li>
</ol>
<p>In all other cases, we’re forced to return <code>Nothing</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="ot">maybeApply ::</span> <span class="dt">SemE</span> expr <span class="ot">=&gt;</span> <span class="dt">Typed</span> expr <span class="ot">-&gt;</span> <span class="dt">Typed</span> expr <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Typed</span> expr)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>maybeApply (<span class="dt">Typed</span> (a1,x)) (<span class="dt">Typed</span> (a2 <span class="op">:%</span>\ b,f)) <span class="ot">=</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>  <span class="kw">case</span> a1 <span class="op">%~</span> a2 <span class="kw">of</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>    <span class="dt">Proved</span> <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> (<span class="dt">Typed</span> (b, apply f x))</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>    _           <span class="ot">-&gt;</span> empty</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>maybeApply (<span class="dt">Typed</span> (b <span class="op">:%/</span> a1,f)) (<span class="dt">Typed</span> (a2,x)) <span class="ot">=</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>  <span class="kw">case</span> a1 <span class="op">%~</span> a2 <span class="kw">of</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>    <span class="dt">Proved</span> <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> (<span class="dt">Typed</span> (b, apply f x))</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>    _           <span class="ot">-&gt;</span> empty</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a>maybeApply _ _ <span class="ot">=</span> empty</span></code></pre></div>
<p>What we’ve implemented above is just a <em>check</em> to see if some given pair of expressions can be applied as function and argument. Applied repeatedly, this corresponds to checking if some given syntax tree has a well-typed function-argument structure. If we want to do this, we’re going to need some sort of trees:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Tree</span> a <span class="ot">=</span> <span class="dt">Leaf</span> a <span class="op">|</span> <span class="dt">Node</span> (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>            <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>)</span></code></pre></div>
<p>However, since we don’t actually want to write these horribly verbose things, we’re going to use parser combinators to implement a tiny parser which parses sentences of the form “(the unicorn) (found jack) first”:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="ot">parseTree ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Tree</span> <span class="dt">String</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>parseTree str <span class="ot">=</span> <span class="kw">case</span> parse sent <span class="st">&quot;&quot;</span> str <span class="kw">of</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>  <span class="dt">Left</span>  _ <span class="ot">-&gt;</span> empty</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>  <span class="dt">Right</span> t <span class="ot">-&gt;</span> <span class="fu">pure</span> t</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>    sent <span class="ot">=</span> chainr1 atom node</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>      <span class="kw">where</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>        word <span class="ot">=</span> <span class="dt">Leaf</span> <span class="op">&lt;$&gt;</span> many1 letter</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>        atom <span class="ot">=</span> word <span class="op">&lt;|&gt;</span> (char <span class="ch">&#39;(&#39;</span> <span class="op">*&gt;</span> (sent <span class="op">&lt;*</span> char <span class="ch">&#39;)&#39;</span>))</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>        node <span class="ot">=</span> <span class="fu">pure</span> <span class="dt">Node</span> <span class="op">&lt;*</span> spaces</span></code></pre></div>
<p>That is to say, for our parser, spaces form nodes in the tree, and are taken to be right associative. So, the example above represents the following tree:</p>
<pre><code>        -----------
       /           \
      /           ----
     /           /    \
   ----        ----    \
  /    \      /    \    \
the unicorn found jack first</code></pre>
<p>Last, before we can write out full implementation of “parsing” with AB grammars, we’re going to need the concept of a lexicon. In our case, a lexicon will be a function from string to lists of typed expressions (because a word can have multiple interpretations):</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Lexicon</span> expr <span class="ot">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Typed</span> expr]</span></code></pre></div>
<p>Parsing consists of four stages:</p>
<ol type="1">
<li>we parse the given string into a tree;</li>
<li>we look up the words in the tree in the lexicon;</li>
<li>we combine the words using <code>maybeApply</code> as defined above; and</li>
<li>we return those resulting terms that are of the correct type.</li>
</ol>
<p>Below, you see the function written out in full. Note that the <code>checkType</code> function once again makes use of the type-level equality function <code>%~</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="ot">parseWith ::</span> <span class="dt">SemE</span> expr </span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>          <span class="ot">=&gt;</span> <span class="dt">Lexicon</span> expr <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SSynT</span> a <span class="ot">-&gt;</span> [expr (<span class="dt">Tr</span> a)]</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>parseWith <span class="fu">lex</span> str a1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>    wordTree <span class="ot">&lt;-</span> maybeToList (parseTree str)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>    exprTree <span class="ot">&lt;-</span> <span class="fu">traverse</span> <span class="fu">lex</span> wordTree</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>    expr     <span class="ot">&lt;-</span> combine exprTree</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>    checkType expr</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>    <span class="kw">where</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>      <span class="co">-- Check if type a1 == a2, and if so return the</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true"></a>      <span class="co">-- expression. Otherwise return Nothing.</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true"></a>      checkType (<span class="dt">Typed</span> (a2,x)) <span class="ot">=</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true"></a>        <span class="kw">case</span> a1 <span class="op">%~</span> a2 <span class="kw">of</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true"></a>          <span class="dt">Proved</span> <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> x</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true"></a>          _           <span class="ot">-&gt;</span> empty</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true"></a></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true"></a>      <span class="co">-- Combine the expressions in the tree using the maybeApply</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true"></a>      <span class="co">-- function, defined above.</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true"></a>      combine (<span class="dt">Leaf</span> e)     <span class="ot">=</span> <span class="fu">pure</span> e</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true"></a>      combine (<span class="dt">Node</span> t1 t2) <span class="ot">=</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true"></a>        <span class="kw">do</span> e1 <span class="ot">&lt;-</span> combine t1</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true"></a>           e2 <span class="ot">&lt;-</span> combine t2</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true"></a>           maybeToList (maybeApply e1 e2)</span></code></pre></div>
<h2 id="interpretations-in-haskell">Interpretations in Haskell</h2>
<p>Now comes the part where all this mucking about with singleton types really pays off. Because our expressions are typed, and sound with respect to Haskell’s type system, we can choose Haskell to be our semantic language. That means that we now have the ability to parse strings to valid Haskell functions.</p>
<p>First, let’s set up a small language to represent our world, which in this case is mostly made up of Bob and Tim:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Entity</span> <span class="ot">=</span> <span class="dt">Tim</span> <span class="co">-- ^ Tim is a carpenter and an introvert, likes</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>                  <span class="co">--   holding hands and long walks on the beach.</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>            <span class="op">|</span> <span class="dt">Bob</span> <span class="co">-- ^ Bob is an aspiring actor, and a social media</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>                  <span class="co">--   junkie. Likes travelling, beer, and Tim.</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>            <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Pred</span> <span class="ot">=</span> <span class="dt">Like</span> <span class="dt">Entity</span> <span class="dt">Entity</span> <span class="co">-- ^ Is it &#39;like&#39; or &#39;like like&#39;?</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>          <span class="op">|</span> <span class="dt">Stupid</span> <span class="dt">Entity</span>      <span class="co">-- ^ This is definitely not &#39;like like&#39;.</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>          <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
<p>Secondly, we could turn our expressions into plain Haskell expressions, but that would be dull. Language isn’t side-effect free—there’s all kinds of stuff going on! So, we’re going to use a library for <a href="http://okmij.org/ftp/Haskell/extensible/">extensible effects</a> written by Oleg Kiselyov, Amr Sabry, Cameron Swords, and Hiromi Ishii.</p>
<p>Let’s translate our semantic types into effectful Haskell types! And, most importantly, let’s keep the set of effects <code>r</code> unspecified!</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">ToEff</span> r<span class="ot"> t ::</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>  <span class="dt">ToEff</span> r <span class="dt">E</span>         <span class="ot">=</span> <span class="dt">Eff</span> r <span class="dt">Entity</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>  <span class="dt">ToEff</span> r <span class="dt">T</span>         <span class="ot">=</span> <span class="dt">Eff</span> r <span class="dt">Pred</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>  <span class="dt">ToEff</span> r (a <span class="op">:-&gt;</span> b) <span class="ot">=</span> <span class="dt">ToEff</span> r a <span class="ot">-&gt;</span> <span class="dt">ToEff</span> r b</span></code></pre></div>
<p>Now, because Haskell is being a buzzkill about using un-saturated type families, we have to wrap our translation in a newtype to be able to use it with the <code>Typed</code> definition and the <code>SemE</code> type class. And because of this, we also have to convince Haskell that these wrapped Haskell functions can be applied:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Ext</span> r a <span class="ot">=</span> <span class="dt">Ext</span> (<span class="dt">ToEff</span> r a)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">SemE</span> (<span class="dt">Ext</span> r) <span class="kw">where</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>  apply (<span class="dt">Ext</span> f) (<span class="dt">Ext</span> x) <span class="ot">=</span> <span class="dt">Ext</span> (f x)</span></code></pre></div>
<p>But now we’re all ready to go! First, let’s determine the effects we want to use in our library. We could still leave this under specified, and only mention which effects we expect to be supported… but that would be much more verbose:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">RW</span> <span class="ot">=</span> (<span class="dt">Reader</span> <span class="dt">Entity</span> &#39;<span class="op">:</span> <span class="dt">Writer</span> <span class="dt">Pred</span> &#39;<span class="op">:</span> &#39;[])</span></code></pre></div>
<p>Hooray! We can have a lexicon now! And it’s reasonably simple, too!</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="fu">lex</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Typed</span> (<span class="dt">Ext</span> <span class="dt">RW</span>)]</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span class="fu">lex</span> <span class="st">&quot;tim&quot;</span>    <span class="ot">=</span> [ <span class="dt">Typed</span> (<span class="dt">SNP</span> , <span class="dt">Ext</span> (<span class="fu">pure</span> <span class="dt">Tim</span>))                            ]</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a><span class="fu">lex</span> <span class="st">&quot;bob&quot;</span>    <span class="ot">=</span> [ <span class="dt">Typed</span> (<span class="dt">SNP</span> , <span class="dt">Ext</span> (<span class="fu">pure</span> <span class="dt">Bob</span>))                            ]</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a><span class="fu">lex</span> <span class="st">&quot;likes&quot;</span>  <span class="ot">=</span> [ <span class="dt">Typed</span> (sTV , <span class="dt">Ext</span> (liftA2 (<span class="fu">flip</span> <span class="dt">Like</span>)))                  ]</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a><span class="fu">lex</span> <span class="st">&quot;stupid&quot;</span> <span class="ot">=</span> [ <span class="dt">Typed</span> (sAP , <span class="dt">Ext</span> (<span class="op">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> tell (<span class="dt">Stupid</span> x) <span class="op">*&gt;</span> <span class="fu">pure</span> x)) ]</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a><span class="fu">lex</span> <span class="st">&quot;him&quot;</span>    <span class="ot">=</span> [ <span class="dt">Typed</span> (<span class="dt">SNP</span> , <span class="dt">Ext</span> ask)                                   ]</span></code></pre></div>
<p>The first two definitions simply return Tim and Bob as effect-free constants—hence the application of <code>pure</code>. Tim and Bob are both of type <code>Entity</code>, and through our translation, <code>NP</code> gets translated to <code>Eff r Entity</code>, so this works out.</p>
<p>Then, the predicate <code>Like</code> is simply lifted by <code>liftA2</code>, which is similar to <code>pure</code>, but for binary functions. The <code>flip</code> is present because according to… <em>egh</em>… <em>grammar</em>, <code>Like</code> will take its object first and its subject second… but for readability, we’d like that to be the other way around.</p>
<p>The definition for “stupid” acts as an identity function on entities, but inserts a predicate into the “appositive dimension”. This corresponds to the linguistic analysis of expressives: they don’t contribute to the sentence meaning, but store their meanings in some other meaning dimension—in this case, a <code>Writer</code> monad!</p>
<p>And last, the definition for “him” simply asks a <code>Reader</code> monad what it’s interpretation should be! A more complex example of anaphora resolution would be to also include a <code>Writer</code> monad, and have entities submit themselves as potential referents, then have this <code>Writer</code> monad periodically empty itself into the <code>Reader</code> monad, e.g. at sentence or clause boundaries, and have anaphora consume the first appropriate referent… But we digress!</p>
<p>We’re still stuck with these unresolved effects coming from our lexicon. So we’re going to define a function <code>runExt</code>, which handles all effects in order, and then escapes the <code>Eff</code> monad:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="ot">runExt ::</span> <span class="dt">Entity</span> <span class="ot">-&gt;</span> <span class="dt">Ext</span> <span class="dt">RW</span> <span class="dt">T</span> <span class="ot">-&gt;</span> (<span class="dt">Pred</span>, [<span class="dt">Pred</span>])</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>runExt x (<span class="dt">Ext</span> e) <span class="ot">=</span> run (runWriter (runReader e x))</span></code></pre></div>
<p>And with all this in place, we can handle an example sentence:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="ot">example ::</span> [(<span class="dt">Pred</span>, [<span class="dt">Pred</span>])]</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>example <span class="ot">=</span> runExt <span class="dt">Tim</span> <span class="op">&lt;$&gt;</span> parseWith <span class="fu">lex</span> <span class="st">&quot;(stupid bob) likes him&quot;</span> <span class="dt">SS</span></span></code></pre></div>
<p>Which evaluates to: <code>[(Like Bob Tim,[Stupid Bob])]</code></p>
<hr />
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>For a more hands-on implementation of side-effects in natural language using <em>monads</em>, see <a href="https://github.com/dylnb/esslli2015-monads" class="uri">https://github.com/dylnb/esslli2015-monads</a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>The convention in the singletons library is to define the singleton version of a constructor by prefixing it with an <code>S</code>. Obviously, since the above definitions aren’t constructors, we can’t do that. However, we stick as close to the convention as possible in naming these “derived” singletons <code>sIV</code>, <code>sTV</code> and <code>sAP</code>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>It is the repeated application of this function which corresponds to backward-chaining proof search in the more general framework of categorial grammar. However, AB grammars <em>only</em> support function application, and therefore our “proof search” (1) can return at most one result, and (2) is more-or-less just a cursory check to see if the types match.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></description>
    <pubDate>Wed, 09 Mar 2016 12:00:00 UT</pubDate>
    <guid>http://wenkokke.github.io/posts/2016-03-09-side-effects-in-english.html</guid>
    <dc:creator>Wen Kokke</dc:creator>
</item>

    </channel>
</rss>
