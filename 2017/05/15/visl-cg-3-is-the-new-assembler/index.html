<!DOCTYPE html><html lang="en-GB"><head><meta charset="utf-8"><link href="http://gmpg.org/xfn/11" rel="profile"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>VISL CG-3 is the new assembler</title><link rel="stylesheet" href="../../../../assets/css/style.css"><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../../rss.xml"><script>document.addEventListener("DOMContentLoaded",function(){var e;for(e of document.querySelectorAll(".citation")){var t=e.getAttribute("DATA-CITES").split(" ");const n=document.createElement("A");n.innerHTML=e.innerHTML,n.setAttribute("href","#"+t),e.replaceWith(n)}})</script></head><body><header class="sidebar"><div class="container sidebar-sticky"><div class="sidebar-about"><img class="sidebar-about-photo" src="../../../../assets/images/me.png" alt="It&#39;s me!"><h1><a href="https://wen.works">All The Language</a></h1><p class="lead">Hiya! I&#39;m <span class="tooltip" title="/w…õn/">Wen</span>. I study natural language, programming languages and logical languages. Basically, all the language‚Ä¶</p></div><nav class="sidebar-nav"><a class="sidebar-nav-item" href="../../../../">Blog </a><a class="sidebar-nav-item" href="../../../../pubs/">Pubs</a></nav><nav class="sidebar-nav"><a class="sidebar-nav-item sidebar-nav-icon" href="mailto:me@wen.works"><i class="far fa-envelope"></i> </a><a class="sidebar-nav-item sidebar-nav-icon" href="https://github.com/wenkokke"><i class="fab fa-github"></i> </a><a class="sidebar-nav-item sidebar-nav-icon" href="https://twitter.com/wenkokke"><i class="fab fa-twitter"></i> </a><a class="sidebar-nav-item sidebar-nav-icon" href="https://www.paypal.me/wenkokke"><i class="fab fa-paypal"></i></a></nav><div class="sidebar-about">¬© 2016‚Äî2022. All rights reserved.</div></div></header><main class="content container"><article class="post"><header><h2 class="post-title">VISL CG-3 is the new assembler</h2></header><footer class="post-date">Mon 15 May, 2017</footer><p>This post is a continuation of <em><a href="../../../../2016/03/16/constraint-grammar-can-count/">Constraint Grammar can count!</a></em>, in which I talked a bunch about how expressive constraint grammar is. Now, for most of that post, what I actually meant was the fragment of constraint grammar where you only use the <code>REMOVE</code> rule.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> However, I always had the suspicion that I‚Äôd be pretty easy to simulate a Turing machine using only the <code>ADDCOHORT</code> and <code>REMCOHORT</code> commands, treating the list of cohorts as the Turing machine‚Äôs tape‚Äîand I don‚Äôt think I was the only one to feel that way.</p><p>Now, this would be wonderful news. It would prove that <code>ADDCOHORT</code> and <code>REMCOHORT</code> are Turing-complete‚Äîgiven that VISL CG-3 itself is a pretty decent proof that we can run constraint grammars on a universal computer. Not only that, but VISL CG-3 is an extremely optimized piece of software‚Äîso the fact that we could compile <em>any Turing machine</em> to VISL CG-3 would be great news for the HPC community<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p><p>With all this in mind, I decided to finally work out the details of this compiler I had had tumbling around in my brain for the past months. Turns out, it‚Äôs kinda nice.</p><p>For this post, we‚Äôll encode the first Turing machine program I could find, using a quick search, as a constraint grammar, using only <code>ADDCOHORT</code> and <code>REMCOHORT</code><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> I‚Äôll try to explain the general principle as we go. But first, I should probably briefly go over how a Turing machine works‚Äîthough I hope you‚Äôll forgive me if I‚Äôll be a little informal. <em>Heads-up</em>: If you don‚Äôt want to read through a whole bunch about Turing machines, it‚Äôs probably best to skip right to <a href="#visl-cg-3-turing-machines">the meat</a>.</p><h3 id="so-whats-this-turing-machine-business">So what‚Äôs this Turing machine business?</h3><p>A Turing machine is a tiny machine, which sits whirring away on top of an infinite roll of tape. It has a head, which hoovers over the tape, and reads and writes whatever cell it happens to hoover over. It also has a state. This is basically saying that it can remember what it was doing, but practically speaking this‚Äôll be some number. The number of the thing it was supposed to be doing. It was never supposed to be built, but of course someone did:</p><p><img src="../../../../assets/images/model-of-a-turing-machine.jpg" alt="An actual Turing machine."><br></p><p>Actually, many people have built one. Out of everything from <a href="https://web.archive.org/web/20150924052601/https://www.newscientist.com/blogs/nstv/2011/03/turing-machine-built-from-wood-and-scrap-metal.html">wood and scrap metal</a>, to <a href="http://web.archive.org/web/20170513045644/http://www.legoturingmachine.org/lego-turing-machine/">Legos</a>, to <a href="http://dx.doi.org/10.1063/1.4793648">artificial muscle</a>.</p><p>Anyway. What makes every Turing machine special is that each has it‚Äôs own unique table, which contains its own unique program. At every step, the Turing machine will use its head to read the cell it‚Äôs hoovering over, and then sorta feel its state, and it will consult the great big (or sometimes small) table of its program. The table will then tell it what to do. What it should write over the thing it just read, what its next state should be, and whether it should whirr the tape to the left or to the right. It‚Äôll do this until the table says it should enter its stop state. Then it stops. Some Turing machines have faulty tables, which never let it reach a stopping state.</p><p>Now, it just so happens that the first search result for ‚ÄúTuring machine example program‚Äù on the day I wrote this post was a machine which increments binary numbers, and its table looked like this:</p><p><a href="https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/turing-machine/four.html"><img src="../../../../assets/images/bit-succ-tm.png" alt="Transition function for a Turing machine which computes the binary successor."></a></p><p>These programs are a little hard to read, so let‚Äôs go over what the Turing machine will be doing at each of these states.</p><p><strong>State 0</strong> The machine expects its input‚Äîthat number we‚Äôre going to increment‚Äîto already be written on the tape. However, it doesn‚Äôt trust us to place its head directly at the beginning of said number. So, state 0 is there so that wherever in the number we put its head, it will move right to the start. Then it continues in state 1.</p><p><strong>State 1</strong> All the real work is done in state 1. In state 1, the Turing machine is in the business of progressivly moving its head to the right. It will overwrite any <code>1</code> it meets with a <code>0</code>. But if it <em>ever</em> reads a <code>0</code> or a blank, it will write a <code>1</code> and continue in state 2.</p><p><strong>State 2</strong> A brief check with your binary arithmetic will tell you we‚Äôve already incremented the number in the previous state. So what is state 2 there for? It does the same thing as state 0. For reasons of cleanliness, and being a good bot, it moves its head back to the beginning of the number. And when it has done that, it stops.</p><p>Below is the trace for the machine incrementing the number 11 to 12, or <code>1011</code> to <code>1100</code> in binary. I‚Äôve put a ü§ñ, to show you where the machine is looking:</p><pre><code>_	_ ü§ñ	1	1	0	1 # 0: Read 1, Write 1, Move ‚Üê
_ ü§ñ	_	1	1	0	1 # 0: Read _, Write _, Move ‚Üí
_	_ ü§ñ	1	1	0	1 # 1: Read 1, Write 0, Move ‚Üí
_	_	0 ü§ñ	1	0	1 # 1: Read 1, Write 0, Move ‚Üí
_	_	0	0 ü§ñ	0	1 # 1: Read 0, Write 1, Move ‚Üê
_	_	0 ü§ñ	0	1	1 # 2: Read 0, Write 0, Move ‚Üê
_	_ ü§ñ	0	0	1	1 # 2: Read 0, Write 0, Move ‚Üê
_ ü§ñ	_	0	0	1	1 # 2: Read _, Write _, Move ‚Üí
_	_ ü§ñ	0	0	1	1 # Stop</code></pre><p>Great! So now we‚Äôve got that out of the way, let‚Äôs have a look at implementing this machine in VISL CG-3, because why not?</p><h3 id="visl-cg-3-turing-machines">VISL CG-3 Turing Machines</h3><p>We‚Äôre going to represent the Turing machine‚Äôs tape as a list of cohorts. This means that when we pass in the number 11, we pass VISL CG-3 the following text:</p><div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;1&quot;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;1&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;0&quot;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;1&quot;</span></span></code></pre></div><p>We will take a cue from the nice infix notation we used above, and write the current state to the tape, right before the cell which the head is currently on. For instance, the third row in the execution trace above would be written as:</p><div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;0&quot;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;&lt;State&gt;&quot;</span> <span class="st">&quot;State1&quot;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;1&quot;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;0&quot;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;1&quot;</span></span></code></pre></div><p>To start off, our constraint grammar will add a cohort for the start state. It‚Äôll add it right before the first cell of our input. This kind-of makes the whole of state 0 superfluous, but we‚Äôll keep it anyway, for good form:</p><div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>BEFORE<span class="op">-</span>SECTIONS</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>ADDCOHORT (<span class="st">&quot;&lt;State&gt;&quot;</span> <span class="st">&quot;State0&quot;</span>) BEFORE (<span class="st">&quot;&lt;Cell&gt;&quot;</span>) IF (<span class="op">-</span><span class="dv">1</span> (<span class="op">&gt;&gt;&gt;</span>))<span class="op">;</span></span></code></pre></div><p>Now the meat. We will encode the program of our Turing machine. This is a recursive specification, we we‚Äôll need to wrap it in a <code>SECTION</code>. First, we mark the current state cohort and the cell we‚Äôre reading as old:</p><div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>ADD (<span class="st">&quot;&lt;State&gt;&quot;</span> <span class="st">&quot;OLD&quot;</span>) (<span class="st">&quot;&lt;State&gt;&quot;</span>)<span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>ADD (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;OLD&quot;</span>) (<span class="st">&quot;&lt;Cell&gt;&quot;</span>) IF (<span class="op">-</span><span class="dv">1</span> (<span class="st">&quot;&lt;State&gt;&quot;</span> <span class="st">&quot;OLD&quot;</span>))<span class="op">;</span></span></code></pre></div><p>I realise that these are <code>ADD</code> commands, and I promised to only use <code>ADDCOHORT</code> and <code>REMCOHORT</code>, but hear me out. We can simulate this usage of <code>ADD</code> by adding a cohort <code>&quot;&lt;Old&gt;&quot;</code> <em>after</em> the cohort we‚Äôre marking. However, every time we now select a cohort using e.g.¬†<code>(&quot;&lt;Cell&gt;&quot; &quot;OLD&quot;)</code>, we‚Äôd have to change this to <code>(0 (&quot;&lt;Cell&gt;&quot;) LINK 1 (&quot;&lt;Old&gt;&quot;))</code>‚Ä¶ and we‚Äôd have to take into account the expected number of <code>&quot;&lt;Old&gt;&quot;</code> cohorts, and move every selection by that. Anyway, it wouldn‚Äôt be pretty. So please allow me this one thing. Ok?</p><p>Back to our scheduled program. Once we‚Äôve marked our old state cohort and the cell we‚Äôre reading as old, we can introduce new ones. We will compile every single entry in the Turing machine‚Äôs program to <em>two</em> rules. One which introduces the next state, and one which writes a new cell to replace the old one. For instance, the rule which says that ‚Äúif we are in state 1, and we read a 1, then we write a 0, move the tape to the right, and continue in state 1,‚Äù is compiled to the following two rules:</p><div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>ADDCOHORT (<span class="st">&quot;&lt;State&gt;&quot;</span> <span class="st">&quot;State1&quot;</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>   BEFORE (<span class="st">&quot;&lt;Cell&gt;&quot;</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>       IF (<span class="op">-</span><span class="dv">2</span> (<span class="st">&quot;&lt;State&gt;&quot;</span> <span class="st">&quot;State1&quot;</span> <span class="st">&quot;OLD&quot;</span>) LINK</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>            <span class="dv">1</span> (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;1&quot;</span> <span class="st">&quot;OLD&quot;</span>))<span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>ADDCOHORT (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;0&quot;</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    AFTER (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;1&quot;</span> <span class="st">&quot;OLD&quot;</span>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>       IF (<span class="op">-</span><span class="dv">1</span> (<span class="st">&quot;&lt;State&gt;&quot;</span> <span class="st">&quot;State1&quot;</span> <span class="st">&quot;OLD&quot;</span>))<span class="op">;</span></span></code></pre></div><p>And the rule which says that ‚Äúif we are in state 1, and we read a blank, then we write a 1, move the tape to the left, and change to state 2‚Äù is compiled to the following two rules:</p><div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>ADDCOHORT (<span class="st">&quot;&lt;State&gt;&quot;</span> <span class="st">&quot;State2&quot;</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>   BEFORE (<span class="st">&quot;&lt;Cell&gt;&quot;</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>       IF (<span class="dv">1</span> (<span class="st">&quot;&lt;State&gt;&quot;</span> <span class="st">&quot;State1&quot;</span> <span class="st">&quot;OLD&quot;</span>) LINK</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>           <span class="dv">1</span> (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;_&quot;</span> <span class="st">&quot;OLD&quot;</span>))<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>ADDCOHORT (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;1&quot;</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    AFTER (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;_&quot;</span> <span class="st">&quot;OLD&quot;</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>       IF (<span class="op">-</span><span class="dv">1</span> (<span class="st">&quot;&lt;State&gt;&quot;</span> <span class="st">&quot;State1&quot;</span> <span class="st">&quot;OLD&quot;</span>))<span class="op">;</span></span></code></pre></div><p>In both pairs, the first rule inserts the next state in the appropriate place, and the second rule inserts the newly written cell after the one marked as old.</p><p>After all these rules‚Äîof which at most one pair will match, because we check for both the state and the cell marked as old‚Äîwe clean up, simply removing every cohort marked as old:</p><div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>REMCOHORT (<span class="st">&quot;&lt;State&gt;&quot;</span> <span class="st">&quot;OLD&quot;</span>)<span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>REMCOHORT (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;OLD&quot;</span>)<span class="op">;</span></span></code></pre></div><p>This cycle of marking as old, applying the transitions, and removing the old cohorts will repeat until there are no further changes. Since there are no transitions which match on a stop state, the repetitions will stop here, and the stop state will be marked as old and removed.</p><p>Finally, because moving the head back to the start of the number is rather pointless in this implementation, we have a final cleanup step. We remove any leading or trailing blank cells:</p><div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>AFTER<span class="op">-</span>SECTIONS</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>REMCOHORT (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;_&quot;</span>) IF (NOT <span class="op">-</span><span class="dv">1</span><span class="op">*</span> SYMB)<span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>REMCOHORT (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;_&quot;</span>) IF (NOT  <span class="dv">1</span><span class="op">*</span> SYMB)<span class="op">;</span></span></code></pre></div><p>Hooray! We‚Äôve implemented a Turing machine! Or have we? There‚Äôs one tiny issue with the above implementation. Our little Turing machine sits whirring on top of an <em>infinite</em> amount of tape. Here, our implementation only ever writes to cells which were already filled in the input. This means we‚Äôve actually been implementing a linear bounded automaton all this time‚Äîi.e.¬†we‚Äôve proven that <code>ADDCOHORT</code> and <code>REMCOHORT</code> cover at least the context-sensitive languages! But really, we‚Äôd like to be able to simulate Turing machines, so‚Ä¶</p><p>There is a simple way to extend this framework to Turing machines. We add two rules, <em>right</em> at the start of the <code>SECTION</code>, which simply add more blank cells to the edges of the tape whenever the head gets too close:</p><div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>ADDCOHORT (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;_&quot;</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>   BEFORE (<span class="st">&quot;&lt;State&gt;&quot;</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>       IF (<span class="op">-</span><span class="dv">1</span> (<span class="op">&gt;&gt;&gt;</span>))<span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>ADDCOHORT (<span class="st">&quot;&lt;Cell&gt;&quot;</span> <span class="st">&quot;_&quot;</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    AFTER (<span class="st">&quot;&lt;Cell&gt;&quot;</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>       IF (<span class="dv">0</span> (<span class="op">&lt;&lt;&lt;</span>) LINK <span class="op">-</span><span class="dv">1</span> (<span class="st">&quot;&lt;State&gt;&quot;</span>))<span class="op">;</span></span></code></pre></div><p>The first of these rules adds a blank cell at the beginning if the state cohort is the <em>first</em> cohort. The second adds a blank cell at the end if the state cohort is the second-to-last cohort‚Äîbecause, remember, we are reading the cell right after the cohort.</p><p>Now if you‚Äôre thinking ‚ÄúVISL CG-3 is known for being fast; I can‚Äôt wait to compile all my code to it!‚Äù then I have to tell you‚Äîway ahead of you. I‚Äôve implemented this TM to CG compile as a small Haskell library, in addition to a small Turing machine interpreter, so you can really see just <em>how</em> much time you‚Äôre saving. I‚Äôve also implemented my example machine, the binary successor function, and wrote a set of QuickCheck functions which compare:</p><ul><li>Haskell‚Äôs <code>(+1)</code>;</li><li>the interpreted binary successor machine; and</li><li>the compiled binary successor in VISL CG-3.</li></ul><p>Turns out, everthing works!<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> If you want to have a go‚Äîmaybe implement that sorting algorithm so you can <em>really</em> do a speed comparison‚Äîthe library is available <a href="https://github.com/wenkokke/cgtm">on my Github</a>, and you can get VISL CG-3 <a href="http://beta.visl.sdu.dk/cg3/chunked/installation.html">on the internet</a>.</p><hr><section class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1" role="doc-endnote"><p>The reason for this is that the full version of VISL CG-3 has commands such as <code>EXTERNAL</code>, which allow you to call any other program. This obviously simplifies the question of expressiveness‚Äîcan we simulate a Turing machine? Yes, by calling a Turing machine.<a href="#fnref1" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li><li id="fn2" role="doc-endnote"><p>No, it wouldn‚Äôt.<a href="#fnref2" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li><li id="fn3" role="doc-endnote"><p>Well, those and the <code>ADD</code> command‚Äîwe can theoretically encode our use of <code>ADD</code> with <code>ADDCOHORT</code>, but it really doesn‚Äôt get any prettier if we do so.<a href="#fnref3" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li><li id="fn4" role="doc-endnote"><p>For the binary successor machine.<a href="#fnref4" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li></ol></section></article></main></body></html>