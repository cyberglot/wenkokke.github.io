<!DOCTYPE html><html lang="en-GB"><head><meta charset="utf-8"><link href="http://gmpg.org/xfn/11" rel="profile"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>One λ-calculus, many times…</title><link rel="stylesheet" href="../../../../assets/css/style.css"><link rel="stylesheet" href="../../../../assets/css/agda.css"><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../../rss.xml"><script>document.addEventListener("DOMContentLoaded",function(){var e;for(e of document.querySelectorAll(".citation")){var t=e.getAttribute("DATA-CITES").split(" ");const n=document.createElement("A");n.innerHTML=e.innerHTML,n.setAttribute("href","#"+t),e.replaceWith(n)}})</script><link rel="stylesheet" href="../../../../assets/css/katex.min.css"><script defer src="../../../../assets/js/katex.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){const t=document.getElementsByClassName("math");for(var e=[],a=0;a<t.length;a++){var n=t[a].firstChild;"SPAN"==t[a].tagName&&katex.render(n.data,t[a],{displayMode:t[a].classList.contains("display"),throwOnError:!1,macros:e,fleqn:!0})}})</script></head><body><header class="sidebar"><div class="container sidebar-sticky"><div class="sidebar-about"><img class="sidebar-about-photo" src="../../../../assets/images/me.png" alt="It&#39;s me!"><h1><a href="https://wen.works">All The Language</a></h1><p class="lead">Hiya! I&#39;m <span class="tooltip" title="/wɛn/">Wen</span>. I study natural language, programming languages and logical languages. Basically, all the language…</p></div><nav class="sidebar-nav"><a class="sidebar-nav-item" href="../../../../">Blog </a><a class="sidebar-nav-item" href="../../../../pubs/">Pubs</a></nav><nav class="sidebar-nav"><a class="sidebar-nav-item sidebar-nav-icon" href="mailto:me@wen.works"><i class="far fa-envelope"></i> </a><a class="sidebar-nav-item sidebar-nav-icon" href="https://github.com/wenkokke"><i class="fab fa-github"></i> </a><a class="sidebar-nav-item sidebar-nav-icon" href="https://twitter.com/wenkokke"><i class="fab fa-twitter"></i> </a><a class="sidebar-nav-item sidebar-nav-icon" href="https://www.paypal.me/wenkokke"><i class="fab fa-paypal"></i></a></nav><div class="sidebar-about">© 2016—2022. All rights reserved.</div></div></header><main class="content container"><article class="post"><header><h2 class="post-title">One λ-calculus, many times…</h2></header><footer class="post-date">Sun 20 Mar, 2016</footer><p>Previously, I mentioned that one of the most common posts on Agda blogs is implementing the simply-typed λ-calculus. <a href="https://gergo.erdi.hu/blog/2013-05-01-simply_typed_lambda_calculus_in_agda,_without_shortcuts/">Gergő Érdi</a> even goes as far as to call it the FizzBuzz of dependently-typed programming, and rightfully so: If you do a quick search, you’ll find dozens of examples.</p><p>In <em><a href="http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf">Dependently-Typed Programming with Agda</a></em>, Ulf Norell implements a type checker the simply-typed λ-calculus; <a href="http://mazzo.li/posts/Lambda.html">Francesco Mazzoli</a> more or less follows Ulf, but extends his λ-calculus with a primitive operator for addition; and, Gergő Érdi extends Ulf’s approach with a checker for scope and binding.</p><p>I figured it would be more fun if, instead of rewriting the type checker example, I would do something a little bit different. So for my λ-calculus post, I’ll have a look at kinds of different ways of implementing the simply-typed λ-calculus. Today, natural deduction and the sequent calculus.</p><h3 id="natural-deduction-and-the-λ-calculus">Natural Deduction and the λ-Calculus</h3><p>We’ll start our discussion with the syntax of types. Usually, types are defined inductively over some set of atomic types. We don’t really care what these atomic types will be, so we might as well abstract over them:</p><pre class="Agda"><a id="1373" class="Keyword">module</a> <a id="Syntax"></a><a id="1380" href="_site/2016/03/20/one-lambda-calculus-many-times/#1380" class="Module">Syntax</a> <a id="1387" class="Symbol">(</a><a id="1388" href="_site/2016/03/20/one-lambda-calculus-many-times/#1388" class="Bound">Atom</a> <a id="1393" class="Symbol">:</a> <a id="1395" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="1398" class="Symbol">)</a> <a id="1400" class="Keyword">where</a>
</pre><p>But, if it makes you feel better, we can pretend that they’ll be some like this:</p><pre class="Agda Spec">  <a class="Keyword">data</a>↓515&quot;&gt; <a href="#289" class="Module">Atom</a><a> </a><a class="Symbol">:</a><a> </a><a class="PrimitiveType">Set</a><a> </a><a class="Keyword">where</a><a><br>    </a><a href="#538" class="InductiveConstructor">Int</a><a>    </a><a class="Symbol">:</a><a> </a><a href="#516" class="Datatype">Atom</a><a><br>    </a><a href="#555" class="InductiveConstructor">String</a><a> </a><a class="Symbol">:</a><a> </a><a href="#516" class="Datatype">Atom</a></pre><p>Next, we defined our types. Since we’re talking about minimal propositional logic, a type is either atomic (marked by <a class="Agda InductiveConstructor">El</a>) or an implication:</p><pre class="Agda">  <a id="2198" class="Keyword">infixr</a> <a id="2205" class="Number">6</a> <a id="2207" href="_site/2016/03/20/one-lambda-calculus-many-times/#2262" class="InductiveConstructor Operator">_⇒_</a>

  <a id="2214" class="Keyword">data</a> <a id="Syntax.Type"></a><a id="2219" href="_site/2016/03/20/one-lambda-calculus-many-times/#2219" class="Datatype">Type</a> <a id="2224" class="Symbol">:</a> <a id="2226" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="2230" class="Keyword">where</a>
    <a id="Syntax.Type.El"></a><a id="2240" href="_site/2016/03/20/one-lambda-calculus-many-times/#2240" class="InductiveConstructor">El</a>  <a id="2244" class="Symbol">:</a> <a id="2246" href="_site/2016/03/20/one-lambda-calculus-many-times/#1388" class="Bound">Atom</a> <a id="2251" class="Symbol">→</a> <a id="2253" href="_site/2016/03/20/one-lambda-calculus-many-times/#2219" class="Datatype">Type</a>
    <a id="Syntax.Type._⇒_"></a><a id="2262" href="_site/2016/03/20/one-lambda-calculus-many-times/#2262" class="InductiveConstructor Operator">_⇒_</a> <a id="2266" class="Symbol">:</a> <a id="2268" href="_site/2016/03/20/one-lambda-calculus-many-times/#2219" class="Datatype">Type</a> <a id="2273" class="Symbol">→</a> <a id="2275" href="_site/2016/03/20/one-lambda-calculus-many-times/#2219" class="Datatype">Type</a> <a id="2280" class="Symbol">→</a> <a id="2282" href="_site/2016/03/20/one-lambda-calculus-many-times/#2219" class="Datatype">Type</a>
</pre><p>Now we’ll define sequents. Even though this is just a tiny piece of syntax, we should put some thought behind it…</p><p>Traditionally, the antecedent of some sequent would be a <em>set</em> of formulas. However, we’re looking at this from the perspective of λ-calculus, and there may well be a difference between two terms of the same type. This is usually solved by changing the antecedent to a set of <em>type assignments</em>, which means <span class="math inline">x:A</span> and <span class="math inline">y:A</span> are now distinct. From the logical perspective, this is the same as using a <em>bag</em> or <em>multiset</em> antecedent. If we were doing mathematics, we’d be done, but implementation-wise a bag is actually a rather complex beast. For this reason, we’ll use a <em>list</em>:<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><pre class="Agda">  <a id="3633" class="Keyword">infix</a> <a id="3639" class="Number">4</a> <a id="3641" href="_site/2016/03/20/one-lambda-calculus-many-times/#3677" class="InductiveConstructor Operator">_⊢_</a>

  <a id="3648" class="Keyword">data</a> <a id="Syntax.Sequent"></a><a id="3653" href="_site/2016/03/20/one-lambda-calculus-many-times/#3653" class="Datatype">Sequent</a> <a id="3661" class="Symbol">:</a> <a id="3663" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="3667" class="Keyword">where</a>
    <a id="Syntax.Sequent._⊢_"></a><a id="3677" href="_site/2016/03/20/one-lambda-calculus-many-times/#3677" class="InductiveConstructor Operator">_⊢_</a> <a id="3681" class="Symbol">:</a> <a id="3683" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="3688" href="_site/2016/03/20/one-lambda-calculus-many-times/#2219" class="Datatype">Type</a> <a id="3693" class="Symbol">→</a> <a id="3695" href="_site/2016/03/20/one-lambda-calculus-many-times/#2219" class="Datatype">Type</a> <a id="3700" class="Symbol">→</a> <a id="3702" href="_site/2016/03/20/one-lambda-calculus-many-times/#3653" class="Datatype">Sequent</a>
</pre><p>So what does a <em>proof</em> of a sequent look like? The logical system that is most familiar to a computer scientist is probably <em>natural deduction</em>. The natural deduction system for minimal propositional logic has <em>three</em> rules:</p><p><span class="math display">\frac{A \in \Gamma}{\Gamma \vdash A}{\small ax} \quad \frac{A , \Gamma \vdash B}{\Gamma \vdash A \Rightarrow B}{\small{\Rightarrow}\!i} \quad \frac{\Gamma \vdash A \Rightarrow B \quad \Gamma \vdash A}{\Gamma \vdash B}{\small{\Rightarrow}\!e}</span></p><p>Recall that λ-terms are constructed in one of three ways: a λ-term is either a <em>variable</em>, an <em>abstraction</em> or an <em>application</em>:</p><p><span class="math display">M, N ::= x \mid (\lambda x . M) \mid (M\;N)</span></p><p>These correspond exactly to the rules of natural deduction. In fact, in type systems they are usually presented together:</p><p><span class="math display">\frac{(x : A) \in \Gamma}{\Gamma \vdash x : A} \quad \frac{x : A , \Gamma \vdash M : B}{\Gamma \vdash (\lambda x. M) : A \Rightarrow B} \quad \frac{\Gamma \vdash M : A \Rightarrow B \quad \Gamma \vdash N : A}{\Gamma \vdash (M\;N) : B}</span></p><p>However, I like the clean look of the logical notation, so in the interest of keeping things simple I will use that.</p><p>In what follows, we’ll use the following metavariables for types, contexts, and sequents. That means that if you see one of these names, and you can’t find a binding site, it’s implicitly bound at the top-level:</p><pre class="Agda">  <a id="5117" class="Keyword">variable</a> <a id="5126" href="_site/2016/03/20/one-lambda-calculus-many-times/#5126" class="Generalizable">A</a> <a id="5128" href="_site/2016/03/20/one-lambda-calculus-many-times/#5128" class="Generalizable">B</a> <a id="5130" href="_site/2016/03/20/one-lambda-calculus-many-times/#5130" class="Generalizable">C</a> <a id="5132" class="Symbol">:</a> <a id="5134" href="_site/2016/03/20/one-lambda-calculus-many-times/#2219" class="Datatype">Type</a>
  <a id="5141" class="Keyword">variable</a> <a id="5150" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="5152" href="_site/2016/03/20/one-lambda-calculus-many-times/#5152" class="Generalizable">Γ′</a>  <a id="5156" class="Symbol">:</a> <a id="5158" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="5163" href="_site/2016/03/20/one-lambda-calculus-many-times/#2219" class="Datatype">Type</a>
  <a id="5170" class="Keyword">variable</a> <a id="5179" href="_site/2016/03/20/one-lambda-calculus-many-times/#5179" class="Generalizable">S</a>     <a id="5185" class="Symbol">:</a> <a id="5187" href="_site/2016/03/20/one-lambda-calculus-many-times/#3653" class="Datatype">Sequent</a>
</pre><p>We encode the natural deduction system as a datatype, with each rule corresponding to a <em>constructor</em>, and each proof a <em>value</em>:</p><pre class="Agda">  <a id="5336" class="Keyword">infix</a> <a id="5342" class="Number">3</a> <a id="5344" href="_site/2016/03/20/one-lambda-calculus-many-times/#5356" class="Datatype Operator">ND_</a>

  <a id="5351" class="Keyword">data</a> <a id="Syntax.ND_"></a><a id="5356" href="_site/2016/03/20/one-lambda-calculus-many-times/#5356" class="Datatype Operator">ND_</a> <a id="5360" class="Symbol">:</a> <a id="5362" href="_site/2016/03/20/one-lambda-calculus-many-times/#3653" class="Datatype">Sequent</a> <a id="5370" class="Symbol">→</a> <a id="5372" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="5376" class="Keyword">where</a>
    <a id="Syntax.ND_.ax"></a><a id="5386" href="_site/2016/03/20/one-lambda-calculus-many-times/#5386" class="InductiveConstructor">ax</a> <a id="5389" class="Symbol">:</a> <a id="5391" href="_site/2016/03/20/one-lambda-calculus-many-times/#5126" class="Generalizable">A</a> <a id="5393" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Membership.Setoid.html#887" class="Function Operator">∈</a> <a id="5395" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="5397" class="Symbol">→</a> <a id="5399" href="_site/2016/03/20/one-lambda-calculus-many-times/#5356" class="Datatype Operator">ND</a> <a id="5402" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="5404" href="_site/2016/03/20/one-lambda-calculus-many-times/#3677" class="InductiveConstructor Operator">⊢</a> <a id="5406" href="_site/2016/03/20/one-lambda-calculus-many-times/#5126" class="Generalizable">A</a>
    <a id="Syntax.ND_.⇒i"></a><a id="5412" href="_site/2016/03/20/one-lambda-calculus-many-times/#5412" class="InductiveConstructor">⇒i</a> <a id="5415" class="Symbol">:</a> <a id="5417" href="_site/2016/03/20/one-lambda-calculus-many-times/#5356" class="Datatype Operator">ND</a> <a id="5420" href="_site/2016/03/20/one-lambda-calculus-many-times/#5126" class="Generalizable">A</a> <a id="5422" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="5424" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="5426" href="_site/2016/03/20/one-lambda-calculus-many-times/#3677" class="InductiveConstructor Operator">⊢</a> <a id="5428" href="_site/2016/03/20/one-lambda-calculus-many-times/#5128" class="Generalizable">B</a> <a id="5430" class="Symbol">→</a> <a id="5432" href="_site/2016/03/20/one-lambda-calculus-many-times/#5356" class="Datatype Operator">ND</a> <a id="5435" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="5437" href="_site/2016/03/20/one-lambda-calculus-many-times/#3677" class="InductiveConstructor Operator">⊢</a> <a id="5439" href="_site/2016/03/20/one-lambda-calculus-many-times/#5126" class="Generalizable">A</a> <a id="5441" href="_site/2016/03/20/one-lambda-calculus-many-times/#2262" class="InductiveConstructor Operator">⇒</a> <a id="5443" href="_site/2016/03/20/one-lambda-calculus-many-times/#5128" class="Generalizable">B</a>
    <a id="Syntax.ND_.⇒e"></a><a id="5449" href="_site/2016/03/20/one-lambda-calculus-many-times/#5449" class="InductiveConstructor">⇒e</a> <a id="5452" class="Symbol">:</a> <a id="5454" href="_site/2016/03/20/one-lambda-calculus-many-times/#5356" class="Datatype Operator">ND</a> <a id="5457" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="5459" href="_site/2016/03/20/one-lambda-calculus-many-times/#3677" class="InductiveConstructor Operator">⊢</a> <a id="5461" href="_site/2016/03/20/one-lambda-calculus-many-times/#5126" class="Generalizable">A</a> <a id="5463" href="_site/2016/03/20/one-lambda-calculus-many-times/#2262" class="InductiveConstructor Operator">⇒</a> <a id="5465" href="_site/2016/03/20/one-lambda-calculus-many-times/#5128" class="Generalizable">B</a> <a id="5467" class="Symbol">→</a> <a id="5469" href="_site/2016/03/20/one-lambda-calculus-many-times/#5356" class="Datatype Operator">ND</a> <a id="5472" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="5474" href="_site/2016/03/20/one-lambda-calculus-many-times/#3677" class="InductiveConstructor Operator">⊢</a> <a id="5476" href="_site/2016/03/20/one-lambda-calculus-many-times/#5126" class="Generalizable">A</a> <a id="5478" class="Symbol">→</a> <a id="5480" href="_site/2016/03/20/one-lambda-calculus-many-times/#5356" class="Datatype Operator">ND</a> <a id="5483" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="5485" href="_site/2016/03/20/one-lambda-calculus-many-times/#3677" class="InductiveConstructor Operator">⊢</a> <a id="5487" href="_site/2016/03/20/one-lambda-calculus-many-times/#5128" class="Generalizable">B</a>
</pre><p>Note: for the sake of brevity, I’m using an Agda notation in which implicit arguments are hidden. That means that any unbound variable—such as the <span class="math inline">A</span>s, <span class="math inline">B</span>s and <span class="math inline">\Gamma</span>s above—is implicitly universally quantified.</p><p>I prefer to think of things of the type <a class="Agda Datatype Operator">ND</a> as proofs made up of rules, but if you prefer to think of them as programs made up of the constructors of lambda terms, just use the following syntax:</p><pre class="Agda">  <a id="5954" class="Keyword">pattern</a> <a id="Syntax.var"></a><a id="5962" href="_site/2016/03/20/one-lambda-calculus-many-times/#5962" class="InductiveConstructor">var</a>   <a id="5968" href="_site/2016/03/20/one-lambda-calculus-many-times/#5977" class="Bound">x</a> <a id="5970" class="Symbol">=</a> <a id="5972" href="_site/2016/03/20/one-lambda-calculus-many-times/#5386" class="InductiveConstructor">ax</a>   <a id="5977" href="_site/2016/03/20/one-lambda-calculus-many-times/#5977" class="Bound">x</a>
  <a id="5981" class="Keyword">pattern</a> <a id="Syntax.lam"></a><a id="5989" href="_site/2016/03/20/one-lambda-calculus-many-times/#5989" class="InductiveConstructor">lam</a>   <a id="5995" href="_site/2016/03/20/one-lambda-calculus-many-times/#6004" class="Bound">x</a> <a id="5997" class="Symbol">=</a> <a id="5999" href="_site/2016/03/20/one-lambda-calculus-many-times/#5412" class="InductiveConstructor">⇒i</a>   <a id="6004" href="_site/2016/03/20/one-lambda-calculus-many-times/#6004" class="Bound">x</a>
  <a id="6008" class="Keyword">pattern</a> <a id="Syntax._∙_"></a><a id="6016" href="_site/2016/03/20/one-lambda-calculus-many-times/#6016" class="InductiveConstructor Operator">_∙_</a> <a id="6020" href="_site/2016/03/20/one-lambda-calculus-many-times/#6029" class="Bound">f</a> <a id="6022" href="_site/2016/03/20/one-lambda-calculus-many-times/#6031" class="Bound">x</a> <a id="6024" class="Symbol">=</a> <a id="6026" href="_site/2016/03/20/one-lambda-calculus-many-times/#5449" class="InductiveConstructor">⇒e</a> <a id="6029" href="_site/2016/03/20/one-lambda-calculus-many-times/#6029" class="Bound">f</a> <a id="6031" href="_site/2016/03/20/one-lambda-calculus-many-times/#6031" class="Bound">x</a>
</pre><p>Earlier, we made the conscious choice to use <em>lists</em> to represent the antecedent. However, this introduced a minor problem: while two programs of the same type may not do the same thing, they <em>should</em> be equivalent, as far as the type system is concerned, and so it <em>should</em> be possible to rewrite a program which needs <em>two</em> values of type <span class="math inline">A</span> to a program which needs only <em>one</em>.</p><p>Similarily, by using lists, we have introduced a fixed order in our antecedent which isn’t exactly desirable. While they may be different programs, we <em>should</em> be able to rewrite the program <span class="math inline">f : A \to B \to C</span> to receive its arguments in the different order, i.e. to a program <span class="math inline">f\prime : B \to A \to C</span>.</p><p>Collectively, such properties are known as <em>structural</em> properties, and for this particular logic we can summarise them neatly as follows:</p><blockquote><p>If <span class="math inline">\Gamma \subseteq \Gamma\prime</span> and <span class="math inline">\Gamma \vdash A</span>, then <span class="math inline">\Gamma\prime \vdash A</span>.</p></blockquote><p>We can give a proof of this theorem by induction on the structure of natural deduction proofs. Note that we represent the subset relation as a <em>function</em>, that is to say <span class="math inline">\Gamma \subseteq \Gamma\prime</span> is the <em>function</em> <span class="math inline">A\in\Gamma\to A\in\Gamma\prime</span>:</p><pre class="Agda">  <a id="Syntax.struct"></a><a id="7219" href="_site/2016/03/20/one-lambda-calculus-many-times/#7219" class="Function">struct</a> <a id="7226" class="Symbol">:</a> <a id="7228" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="7230" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Binary.Sublist.Setoid.html#1349" class="Function Operator">⊆</a> <a id="7232" href="_site/2016/03/20/one-lambda-calculus-many-times/#5152" class="Generalizable">Γ′</a> <a id="7235" class="Symbol">→</a> <a id="7237" href="_site/2016/03/20/one-lambda-calculus-many-times/#5356" class="Datatype Operator">ND</a> <a id="7240" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="7242" href="_site/2016/03/20/one-lambda-calculus-many-times/#3677" class="InductiveConstructor Operator">⊢</a> <a id="7244" href="_site/2016/03/20/one-lambda-calculus-many-times/#5126" class="Generalizable">A</a> <a id="7246" class="Symbol">→</a> <a id="7248" href="_site/2016/03/20/one-lambda-calculus-many-times/#5356" class="Datatype Operator">ND</a> <a id="7251" href="_site/2016/03/20/one-lambda-calculus-many-times/#5152" class="Generalizable">Γ′</a> <a id="7254" href="_site/2016/03/20/one-lambda-calculus-many-times/#3677" class="InductiveConstructor Operator">⊢</a> <a id="7256" href="_site/2016/03/20/one-lambda-calculus-many-times/#5126" class="Generalizable">A</a>
  <a id="7260" href="_site/2016/03/20/one-lambda-calculus-many-times/#7219" class="Function">struct</a> <a id="7267" href="_site/2016/03/20/one-lambda-calculus-many-times/#7267" class="Bound">Γ⊆Γ′</a> <a id="7272" class="Symbol">(</a><a id="7273" href="_site/2016/03/20/one-lambda-calculus-many-times/#5386" class="InductiveConstructor">ax</a> <a id="7276" href="_site/2016/03/20/one-lambda-calculus-many-times/#7276" class="Bound">x</a><a id="7277" class="Symbol">)</a>   <a id="7281" class="Symbol">=</a> <a id="7283" href="_site/2016/03/20/one-lambda-calculus-many-times/#5386" class="InductiveConstructor">ax</a> <a id="7286" class="Symbol">(</a><a id="7287" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Binary.Sublist.Propositional.html#1176" class="Function">lookup</a> <a id="7294" href="_site/2016/03/20/one-lambda-calculus-many-times/#7267" class="Bound">Γ⊆Γ′</a> <a id="7299" href="_site/2016/03/20/one-lambda-calculus-many-times/#7276" class="Bound">x</a><a id="7300" class="Symbol">)</a>
  <a id="7304" href="_site/2016/03/20/one-lambda-calculus-many-times/#7219" class="Function">struct</a> <a id="7311" href="_site/2016/03/20/one-lambda-calculus-many-times/#7311" class="Bound">Γ⊆Γ′</a> <a id="7316" class="Symbol">(</a><a id="7317" href="_site/2016/03/20/one-lambda-calculus-many-times/#5412" class="InductiveConstructor">⇒i</a> <a id="7320" href="_site/2016/03/20/one-lambda-calculus-many-times/#7320" class="Bound">f</a><a id="7321" class="Symbol">)</a>   <a id="7325" class="Symbol">=</a> <a id="7327" href="_site/2016/03/20/one-lambda-calculus-many-times/#5412" class="InductiveConstructor">⇒i</a> <a id="7330" class="Symbol">(</a><a id="7331" href="_site/2016/03/20/one-lambda-calculus-many-times/#7219" class="Function">struct</a> <a id="7338" class="Symbol">(</a><a id="7339" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Binary.Sublist.Setoid.Properties.html#4573" class="Function">++⁺</a> <a id="7343" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Binary.Sublist.Setoid.html#2455" class="Function">⊆-refl</a> <a id="7350" href="_site/2016/03/20/one-lambda-calculus-many-times/#7311" class="Bound">Γ⊆Γ′</a><a id="7354" class="Symbol">)</a> <a id="7356" href="_site/2016/03/20/one-lambda-calculus-many-times/#7320" class="Bound">f</a><a id="7357" class="Symbol">)</a>
  <a id="7361" href="_site/2016/03/20/one-lambda-calculus-many-times/#7219" class="Function">struct</a> <a id="7368" href="_site/2016/03/20/one-lambda-calculus-many-times/#7368" class="Bound">Γ⊆Γ′</a> <a id="7373" class="Symbol">(</a><a id="7374" href="_site/2016/03/20/one-lambda-calculus-many-times/#5449" class="InductiveConstructor">⇒e</a> <a id="7377" href="_site/2016/03/20/one-lambda-calculus-many-times/#7377" class="Bound">f</a> <a id="7379" href="_site/2016/03/20/one-lambda-calculus-many-times/#7379" class="Bound">g</a><a id="7380" class="Symbol">)</a> <a id="7382" class="Symbol">=</a> <a id="7384" href="_site/2016/03/20/one-lambda-calculus-many-times/#5449" class="InductiveConstructor">⇒e</a> <a id="7387" class="Symbol">(</a><a id="7388" href="_site/2016/03/20/one-lambda-calculus-many-times/#7219" class="Function">struct</a> <a id="7395" href="_site/2016/03/20/one-lambda-calculus-many-times/#7368" class="Bound">Γ⊆Γ′</a> <a id="7400" href="_site/2016/03/20/one-lambda-calculus-many-times/#7377" class="Bound">f</a><a id="7401" class="Symbol">)</a> <a id="7403" class="Symbol">(</a><a id="7404" href="_site/2016/03/20/one-lambda-calculus-many-times/#7219" class="Function">struct</a> <a id="7411" href="_site/2016/03/20/one-lambda-calculus-many-times/#7368" class="Bound">Γ⊆Γ′</a> <a id="7416" href="_site/2016/03/20/one-lambda-calculus-many-times/#7379" class="Bound">g</a><a id="7417" class="Symbol">)</a>
</pre><p>Note that values of type <span class="math inline">A\in\Gamma</span> are constructed using <a class="Agda InductiveConstructor">here</a> and <a class="Agda InductiveConstructor">there</a>, which makes them more or less just numbers, i.e. “first value”, “second value”, etc…</p><p>I mentioned two uses of this structural rule: contracting two different variables of the <em>same</em> type into one, and exchanging the order of the types in the antecedent. There is one more canonical use: <em>weakning</em>.</p><p>Weakening is so obvious to programmers that they don’t really think of it, but what it says is that if you can run a program in <em>some</em> environment, then you should <em>certainly</em> be able to run that program in that enviroment with some irrelevant stuff added to it. Formally, we write it as:</p><pre class="Agda">  <a id="Syntax.w′"></a><a id="8178" href="_site/2016/03/20/one-lambda-calculus-many-times/#8178" class="Function">w′</a> <a id="8181" class="Symbol">:</a> <a id="8183" href="_site/2016/03/20/one-lambda-calculus-many-times/#5356" class="Datatype Operator">ND</a> <a id="8186" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="8188" href="_site/2016/03/20/one-lambda-calculus-many-times/#3677" class="InductiveConstructor Operator">⊢</a> <a id="8190" href="_site/2016/03/20/one-lambda-calculus-many-times/#5128" class="Generalizable">B</a> <a id="8192" class="Symbol">→</a> <a id="8194" href="_site/2016/03/20/one-lambda-calculus-many-times/#5356" class="Datatype Operator">ND</a> <a id="8197" href="_site/2016/03/20/one-lambda-calculus-many-times/#5126" class="Generalizable">A</a> <a id="8199" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="8201" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="8203" href="_site/2016/03/20/one-lambda-calculus-many-times/#3677" class="InductiveConstructor Operator">⊢</a> <a id="8205" href="_site/2016/03/20/one-lambda-calculus-many-times/#5128" class="Generalizable">B</a>
  <a id="8209" href="_site/2016/03/20/one-lambda-calculus-many-times/#8178" class="Function">w′</a> <a id="8212" href="_site/2016/03/20/one-lambda-calculus-many-times/#8212" class="Bound">f</a> <a id="8214" class="Symbol">=</a> <a id="8216" href="_site/2016/03/20/one-lambda-calculus-many-times/#7219" class="Function">struct</a> <a id="8223" class="Symbol">(</a><a id="8224" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Binary.Sublist.Setoid.Properties.html#4431" class="Function">++⁺ˡ</a> <a id="8229" class="Symbol">_</a> <a id="8231" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Binary.Sublist.Setoid.html#2455" class="Function">⊆-refl</a><a id="8237" class="Symbol">)</a> <a id="8239" href="_site/2016/03/20/one-lambda-calculus-many-times/#8212" class="Bound">f</a>
</pre><p>Passing <a class="Agda InductiveConstructor">there</a> to <a class="Agda Function">struct</a> simply moves every value by one: the first value becomes the second, the second becomes the third, etc… In the new antecedent, the first value will be our “irrelevant stuff”.</p><h3 id="sequent-calculus-and-natural-deduction">Sequent Calculus and Natural Deduction</h3><p>We’ve got enough to start talking about the sequent calculus now. The sequent calculus is a different way of writing down logical systems, and it has some pros and cons when compared to natural deduction. It’s usual presentation is as follows:</p><p><span class="math display">\frac{A \in \Gamma}{\Gamma \vdash A}{\small ax} \quad \frac{\Gamma \vdash A \quad A , \Gamma \vdash B}{\Gamma \vdash B}{\small cut} \quad \frac{\Gamma \vdash A \quad B , \Gamma \vdash C}{A \Rightarrow B , \Gamma \vdash C}{\small{\Rightarrow}\!l} \quad \frac{A , \Gamma \vdash B}{\Gamma \vdash A \Rightarrow B}{\small{\Rightarrow}\!r}</span></p><p>We can encode these rules in Agda as follows:</p><pre class="Agda">  <a id="9227" class="Keyword">infix</a> <a id="9233" class="Number">3</a> <a id="9235" href="_site/2016/03/20/one-lambda-calculus-many-times/#9247" class="Datatype Operator">SC_</a>

  <a id="9242" class="Keyword">data</a> <a id="Syntax.SC_"></a><a id="9247" href="_site/2016/03/20/one-lambda-calculus-many-times/#9247" class="Datatype Operator">SC_</a> <a id="9251" class="Symbol">:</a> <a id="9253" href="_site/2016/03/20/one-lambda-calculus-many-times/#3653" class="Datatype">Sequent</a> <a id="9261" class="Symbol">→</a> <a id="9263" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="9267" class="Keyword">where</a>
    <a id="Syntax.SC_.ax"></a><a id="9277" href="_site/2016/03/20/one-lambda-calculus-many-times/#9277" class="InductiveConstructor">ax</a>  <a id="9281" class="Symbol">:</a> <a id="9283" href="_site/2016/03/20/one-lambda-calculus-many-times/#5126" class="Generalizable">A</a> <a id="9285" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Membership.Setoid.html#887" class="Function Operator">∈</a> <a id="9287" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="9289" class="Symbol">→</a> <a id="9291" href="_site/2016/03/20/one-lambda-calculus-many-times/#9247" class="Datatype Operator">SC</a> <a id="9294" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="9296" href="_site/2016/03/20/one-lambda-calculus-many-times/#3677" class="InductiveConstructor Operator">⊢</a> <a id="9298" href="_site/2016/03/20/one-lambda-calculus-many-times/#5126" class="Generalizable">A</a>
    <a id="Syntax.SC_.cut"></a><a id="9304" href="_site/2016/03/20/one-lambda-calculus-many-times/#9304" class="InductiveConstructor">cut</a> <a id="9308" class="Symbol">:</a> <a id="9310" href="_site/2016/03/20/one-lambda-calculus-many-times/#9247" class="Datatype Operator">SC</a> <a id="9313" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="9315" href="_site/2016/03/20/one-lambda-calculus-many-times/#3677" class="InductiveConstructor Operator">⊢</a> <a id="9317" href="_site/2016/03/20/one-lambda-calculus-many-times/#5126" class="Generalizable">A</a> <a id="9319" class="Symbol">→</a> <a id="9321" href="_site/2016/03/20/one-lambda-calculus-many-times/#9247" class="Datatype Operator">SC</a> <a id="9324" href="_site/2016/03/20/one-lambda-calculus-many-times/#5126" class="Generalizable">A</a> <a id="9326" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="9328" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="9330" href="_site/2016/03/20/one-lambda-calculus-many-times/#3677" class="InductiveConstructor Operator">⊢</a> <a id="9332" href="_site/2016/03/20/one-lambda-calculus-many-times/#5128" class="Generalizable">B</a> <a id="9334" class="Symbol">→</a> <a id="9336" href="_site/2016/03/20/one-lambda-calculus-many-times/#9247" class="Datatype Operator">SC</a> <a id="9339" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="9341" href="_site/2016/03/20/one-lambda-calculus-many-times/#3677" class="InductiveConstructor Operator">⊢</a> <a id="9343" href="_site/2016/03/20/one-lambda-calculus-many-times/#5128" class="Generalizable">B</a>
    <a id="Syntax.SC_.⇒l"></a><a id="9349" href="_site/2016/03/20/one-lambda-calculus-many-times/#9349" class="InductiveConstructor">⇒l</a>  <a id="9353" class="Symbol">:</a> <a id="9355" href="_site/2016/03/20/one-lambda-calculus-many-times/#9247" class="Datatype Operator">SC</a> <a id="9358" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="9360" href="_site/2016/03/20/one-lambda-calculus-many-times/#3677" class="InductiveConstructor Operator">⊢</a> <a id="9362" href="_site/2016/03/20/one-lambda-calculus-many-times/#5126" class="Generalizable">A</a> <a id="9364" class="Symbol">→</a> <a id="9366" href="_site/2016/03/20/one-lambda-calculus-many-times/#9247" class="Datatype Operator">SC</a> <a id="9369" href="_site/2016/03/20/one-lambda-calculus-many-times/#5128" class="Generalizable">B</a> <a id="9371" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="9373" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="9375" href="_site/2016/03/20/one-lambda-calculus-many-times/#3677" class="InductiveConstructor Operator">⊢</a> <a id="9377" href="_site/2016/03/20/one-lambda-calculus-many-times/#5130" class="Generalizable">C</a> <a id="9379" class="Symbol">→</a> <a id="9381" href="_site/2016/03/20/one-lambda-calculus-many-times/#9247" class="Datatype Operator">SC</a> <a id="9384" href="_site/2016/03/20/one-lambda-calculus-many-times/#5126" class="Generalizable">A</a> <a id="9386" href="_site/2016/03/20/one-lambda-calculus-many-times/#2262" class="InductiveConstructor Operator">⇒</a> <a id="9388" href="_site/2016/03/20/one-lambda-calculus-many-times/#5128" class="Generalizable">B</a> <a id="9390" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="9392" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="9394" href="_site/2016/03/20/one-lambda-calculus-many-times/#3677" class="InductiveConstructor Operator">⊢</a> <a id="9396" href="_site/2016/03/20/one-lambda-calculus-many-times/#5130" class="Generalizable">C</a>
    <a id="Syntax.SC_.⇒r"></a><a id="9402" href="_site/2016/03/20/one-lambda-calculus-many-times/#9402" class="InductiveConstructor">⇒r</a>  <a id="9406" class="Symbol">:</a> <a id="9408" href="_site/2016/03/20/one-lambda-calculus-many-times/#9247" class="Datatype Operator">SC</a> <a id="9411" href="_site/2016/03/20/one-lambda-calculus-many-times/#5126" class="Generalizable">A</a> <a id="9413" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="9415" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="9417" href="_site/2016/03/20/one-lambda-calculus-many-times/#3677" class="InductiveConstructor Operator">⊢</a> <a id="9419" href="_site/2016/03/20/one-lambda-calculus-many-times/#5128" class="Generalizable">B</a> <a id="9421" class="Symbol">→</a> <a id="9423" href="_site/2016/03/20/one-lambda-calculus-many-times/#9247" class="Datatype Operator">SC</a> <a id="9426" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="9428" href="_site/2016/03/20/one-lambda-calculus-many-times/#3677" class="InductiveConstructor Operator">⊢</a> <a id="9430" href="_site/2016/03/20/one-lambda-calculus-many-times/#5126" class="Generalizable">A</a> <a id="9432" href="_site/2016/03/20/one-lambda-calculus-many-times/#2262" class="InductiveConstructor Operator">⇒</a> <a id="9434" href="_site/2016/03/20/one-lambda-calculus-many-times/#5128" class="Generalizable">B</a>
</pre><p>We will define a few patterns that we’d otherwise have to write out, over and over again. Namely, names for the first, second, and third variable in a context:</p><pre class="Agda">  <a id="9608" class="Keyword">pattern</a> <a id="Syntax.ax₀"></a><a id="9616" href="_site/2016/03/20/one-lambda-calculus-many-times/#9616" class="InductiveConstructor">ax₀</a> <a id="9620" class="Symbol">=</a> <a id="9622" class="InductiveConstructor">ax</a> <a id="9625" class="Symbol">(</a><a id="9626" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html#1219" class="InductiveConstructor">here</a> <a id="9631" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="9635" class="Symbol">)</a>
  <a id="9639" class="Keyword">pattern</a> <a id="Syntax.ax₁"></a><a id="9647" href="_site/2016/03/20/one-lambda-calculus-many-times/#9647" class="InductiveConstructor">ax₁</a> <a id="9651" class="Symbol">=</a> <a id="9653" class="InductiveConstructor">ax</a> <a id="9656" class="Symbol">(</a><a id="9657" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html#1272" class="InductiveConstructor">there</a> <a id="9663" class="Symbol">(</a><a id="9664" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html#1219" class="InductiveConstructor">here</a> <a id="9669" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="9673" class="Symbol">))</a>
  <a id="9678" class="Keyword">pattern</a> <a id="Syntax.ax₂"></a><a id="9686" href="_site/2016/03/20/one-lambda-calculus-many-times/#9686" class="InductiveConstructor">ax₂</a> <a id="9690" class="Symbol">=</a> <a id="9692" class="InductiveConstructor">ax</a> <a id="9695" class="Symbol">(</a><a id="9696" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html#1272" class="InductiveConstructor">there</a> <a id="9702" class="Symbol">(</a><a id="9703" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html#1272" class="InductiveConstructor">there</a> <a id="9709" class="Symbol">(</a><a id="9710" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html#1219" class="InductiveConstructor">here</a> <a id="9715" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="9719" class="Symbol">)))</a>
  <a id="9725" class="Comment">--- etc.</a>
</pre><p>It’s a little bit of a puzzle, but given <a class="Agda Function">w′</a> it becomes quite easy to show that the two logics are in fact equivalent—that they derive the <em>same sequents</em>:</p><pre class="Agda">  <a id="9932" class="Keyword">module</a> <a id="Syntax.ND⇔SC"></a><a id="9939" href="_site/2016/03/20/one-lambda-calculus-many-times/#9939" class="Module">ND⇔SC</a> <a id="9945" class="Keyword">where</a>

    <a id="Syntax.ND⇔SC.⟹"></a><a id="9956" href="_site/2016/03/20/one-lambda-calculus-many-times/#9956" class="Function">⟹</a> <a id="9958" class="Symbol">:</a> <a id="9960" href="_site/2016/03/20/one-lambda-calculus-many-times/#5356" class="Datatype Operator">ND</a> <a id="9963" href="_site/2016/03/20/one-lambda-calculus-many-times/#5179" class="Generalizable">S</a> <a id="9965" class="Symbol">→</a> <a id="9967" href="_site/2016/03/20/one-lambda-calculus-many-times/#9247" class="Datatype Operator">SC</a> <a id="9970" href="_site/2016/03/20/one-lambda-calculus-many-times/#5179" class="Generalizable">S</a>
    <a id="9976" href="_site/2016/03/20/one-lambda-calculus-many-times/#9956" class="Function">⟹</a> <a id="9978" class="Symbol">(</a><a id="9979" href="_site/2016/03/20/one-lambda-calculus-many-times/#5386" class="InductiveConstructor">ax</a> <a id="9982" href="_site/2016/03/20/one-lambda-calculus-many-times/#9982" class="Bound">x</a><a id="9983" class="Symbol">)</a>   <a id="9987" class="Symbol">=</a> <a id="9989" href="_site/2016/03/20/one-lambda-calculus-many-times/#9277" class="InductiveConstructor">ax</a> <a id="9992" href="_site/2016/03/20/one-lambda-calculus-many-times/#9982" class="Bound">x</a>
    <a id="9998" href="_site/2016/03/20/one-lambda-calculus-many-times/#9956" class="Function">⟹</a> <a id="10000" class="Symbol">(</a><a id="10001" href="_site/2016/03/20/one-lambda-calculus-many-times/#5412" class="InductiveConstructor">⇒i</a> <a id="10004" href="_site/2016/03/20/one-lambda-calculus-many-times/#10004" class="Bound">f</a><a id="10005" class="Symbol">)</a>   <a id="10009" class="Symbol">=</a> <a id="10011" href="_site/2016/03/20/one-lambda-calculus-many-times/#9402" class="InductiveConstructor">⇒r</a>  <a id="10015" class="Symbol">(</a><a id="10016" href="_site/2016/03/20/one-lambda-calculus-many-times/#9956" class="Function">⟹</a> <a id="10018" href="_site/2016/03/20/one-lambda-calculus-many-times/#10004" class="Bound">f</a><a id="10019" class="Symbol">)</a>
    <a id="10025" href="_site/2016/03/20/one-lambda-calculus-many-times/#9956" class="Function">⟹</a> <a id="10027" class="Symbol">(</a><a id="10028" href="_site/2016/03/20/one-lambda-calculus-many-times/#5449" class="InductiveConstructor">⇒e</a> <a id="10031" href="_site/2016/03/20/one-lambda-calculus-many-times/#10031" class="Bound">f</a> <a id="10033" href="_site/2016/03/20/one-lambda-calculus-many-times/#10033" class="Bound">g</a><a id="10034" class="Symbol">)</a> <a id="10036" class="Symbol">=</a> <a id="10038" href="_site/2016/03/20/one-lambda-calculus-many-times/#9304" class="InductiveConstructor">cut</a> <a id="10042" class="Symbol">(</a><a id="10043" href="_site/2016/03/20/one-lambda-calculus-many-times/#9956" class="Function">⟹</a> <a id="10045" href="_site/2016/03/20/one-lambda-calculus-many-times/#10031" class="Bound">f</a><a id="10046" class="Symbol">)</a> <a id="10048" class="Symbol">(</a><a id="10049" href="_site/2016/03/20/one-lambda-calculus-many-times/#9349" class="InductiveConstructor">⇒l</a> <a id="10052" class="Symbol">(</a><a id="10053" href="_site/2016/03/20/one-lambda-calculus-many-times/#9956" class="Function">⟹</a> <a id="10055" href="_site/2016/03/20/one-lambda-calculus-many-times/#10033" class="Bound">g</a><a id="10056" class="Symbol">)</a> <a id="10058" href="_site/2016/03/20/one-lambda-calculus-many-times/#9616" class="InductiveConstructor">ax₀</a><a id="10061" class="Symbol">)</a>

    <a id="Syntax.ND⇔SC.⟸"></a><a id="10068" href="_site/2016/03/20/one-lambda-calculus-many-times/#10068" class="Function">⟸</a> <a id="10070" class="Symbol">:</a> <a id="10072" href="_site/2016/03/20/one-lambda-calculus-many-times/#9247" class="Datatype Operator">SC</a> <a id="10075" href="_site/2016/03/20/one-lambda-calculus-many-times/#5179" class="Generalizable">S</a> <a id="10077" class="Symbol">→</a> <a id="10079" href="_site/2016/03/20/one-lambda-calculus-many-times/#5356" class="Datatype Operator">ND</a> <a id="10082" href="_site/2016/03/20/one-lambda-calculus-many-times/#5179" class="Generalizable">S</a>
    <a id="10088" href="_site/2016/03/20/one-lambda-calculus-many-times/#10068" class="Function">⟸</a> <a id="10090" class="Symbol">(</a><a id="10091" href="_site/2016/03/20/one-lambda-calculus-many-times/#9277" class="InductiveConstructor">ax</a>  <a id="10095" href="_site/2016/03/20/one-lambda-calculus-many-times/#10095" class="Bound">p</a><a id="10096" class="Symbol">)</a>   <a id="10100" class="Symbol">=</a> <a id="10102" href="_site/2016/03/20/one-lambda-calculus-many-times/#5386" class="InductiveConstructor">ax</a> <a id="10105" href="_site/2016/03/20/one-lambda-calculus-many-times/#10095" class="Bound">p</a>
    <a id="10111" href="_site/2016/03/20/one-lambda-calculus-many-times/#10068" class="Function">⟸</a> <a id="10113" class="Symbol">(</a><a id="10114" href="_site/2016/03/20/one-lambda-calculus-many-times/#9304" class="InductiveConstructor">cut</a> <a id="10118" href="_site/2016/03/20/one-lambda-calculus-many-times/#10118" class="Bound">f</a> <a id="10120" href="_site/2016/03/20/one-lambda-calculus-many-times/#10120" class="Bound">g</a><a id="10121" class="Symbol">)</a> <a id="10123" class="Symbol">=</a> <a id="10125" href="_site/2016/03/20/one-lambda-calculus-many-times/#5449" class="InductiveConstructor">⇒e</a> <a id="10128" class="Symbol">(</a><a id="10129" href="_site/2016/03/20/one-lambda-calculus-many-times/#5412" class="InductiveConstructor">⇒i</a> <a id="10132" class="Symbol">(</a><a id="10133" href="_site/2016/03/20/one-lambda-calculus-many-times/#10068" class="Function">⟸</a> <a id="10135" href="_site/2016/03/20/one-lambda-calculus-many-times/#10120" class="Bound">g</a><a id="10136" class="Symbol">))</a> <a id="10139" class="Symbol">(</a><a id="10140" href="_site/2016/03/20/one-lambda-calculus-many-times/#10068" class="Function">⟸</a> <a id="10142" href="_site/2016/03/20/one-lambda-calculus-many-times/#10118" class="Bound">f</a><a id="10143" class="Symbol">)</a>
    <a id="10149" href="_site/2016/03/20/one-lambda-calculus-many-times/#10068" class="Function">⟸</a> <a id="10151" class="Symbol">(</a><a id="10152" href="_site/2016/03/20/one-lambda-calculus-many-times/#9349" class="InductiveConstructor">⇒l</a>  <a id="10156" href="_site/2016/03/20/one-lambda-calculus-many-times/#10156" class="Bound">f</a> <a id="10158" href="_site/2016/03/20/one-lambda-calculus-many-times/#10158" class="Bound">g</a><a id="10159" class="Symbol">)</a> <a id="10161" class="Symbol">=</a> <a id="10163" href="_site/2016/03/20/one-lambda-calculus-many-times/#8178" class="Function">w′</a> <a id="10166" class="Symbol">(</a><a id="10167" href="_site/2016/03/20/one-lambda-calculus-many-times/#5412" class="InductiveConstructor">⇒i</a> <a id="10170" class="Symbol">(</a><a id="10171" href="_site/2016/03/20/one-lambda-calculus-many-times/#10068" class="Function">⟸</a> <a id="10173" href="_site/2016/03/20/one-lambda-calculus-many-times/#10158" class="Bound">g</a><a id="10174" class="Symbol">))</a> <a id="10177" href="_site/2016/03/20/one-lambda-calculus-many-times/#6016" class="InductiveConstructor Operator">∙</a> <a id="10179" class="Symbol">(</a><a id="10180" href="_site/2016/03/20/one-lambda-calculus-many-times/#9616" class="InductiveConstructor">ax₀</a> <a id="10184" href="_site/2016/03/20/one-lambda-calculus-many-times/#6016" class="InductiveConstructor Operator">∙</a> <a id="10186" href="_site/2016/03/20/one-lambda-calculus-many-times/#8178" class="Function">w′</a> <a id="10189" class="Symbol">(</a><a id="10190" href="_site/2016/03/20/one-lambda-calculus-many-times/#10068" class="Function">⟸</a> <a id="10192" href="_site/2016/03/20/one-lambda-calculus-many-times/#10156" class="Bound">f</a><a id="10193" class="Symbol">))</a>
    <a id="10200" href="_site/2016/03/20/one-lambda-calculus-many-times/#10068" class="Function">⟸</a> <a id="10202" class="Symbol">(</a><a id="10203" href="_site/2016/03/20/one-lambda-calculus-many-times/#9402" class="InductiveConstructor">⇒r</a>  <a id="10207" href="_site/2016/03/20/one-lambda-calculus-many-times/#10207" class="Bound">f</a><a id="10208" class="Symbol">)</a>   <a id="10212" class="Symbol">=</a> <a id="10214" href="_site/2016/03/20/one-lambda-calculus-many-times/#5412" class="InductiveConstructor">⇒i</a> <a id="10217" class="Symbol">(</a><a id="10218" href="_site/2016/03/20/one-lambda-calculus-many-times/#10068" class="Function">⟸</a> <a id="10220" href="_site/2016/03/20/one-lambda-calculus-many-times/#10207" class="Bound">f</a><a id="10221" class="Symbol">)</a>
</pre><p>The rules for sequent calculus obviously no longer correspond <em>directly</em> to the λ-calculus. However, we’ve just shown that there is in fact <em>some</em> correspondence between them. In the λ-calculus, computation is represented by β-reduction, which is the iterative removal of redexes</p><p><span class="math display">(\lambda x.M)\; N\mapsto M[x := N]</span></p><p>Likewise, sequent calculus comes equipped with its own notion of computation: cut-elimination. And the beautiful thing about cut elimination is that it has a <em>very</em> concrete normal form. Instead of faffing about, claiming the structure is free of β-redexes, cut elimination—as its name implies—allows you to all occurances of the “cut” rule. It would be interesting to show exactly what kind of relation cut elimination has to β-reduction…</p><p><em>Alas</em>! It may be too much effort for a single post to implement both of these logics <em>and</em> a procedure for cut elimination. However, there <em>is</em> a much simpler thing we can do. Agda itself has a pretty servicable implementation of β-reduction for Agda terms, and we can quite easily piggyback on that mechanism. In fact, most of the articles I linked to at the beginning do exactly this.</p><h3 id="interpretations-in-agda">Interpretations in Agda</h3><p>As a first step, we write down what an interpretation is—and since we want to use the intepretation brackets in as many places as possible, we create a type class for it, and give <a class="Agda Field Operator">⟦_⟧</a> the least restrictive type possible:</p><pre class="Agda"><a id="11721" class="Keyword">record</a> <a id="Interpret"></a><a id="11728" href="_site/2016/03/20/one-lambda-calculus-many-times/#11728" class="Record">Interpret</a> <a id="11738" class="Symbol">{</a><a id="11739" href="_site/2016/03/20/one-lambda-calculus-many-times/#11739" class="Bound">a</a><a id="11740" class="Symbol">}</a> <a id="11742" class="Symbol">{</a><a id="11743" href="_site/2016/03/20/one-lambda-calculus-many-times/#11743" class="Bound">b</a><a id="11744" class="Symbol">}</a> <a id="11746" class="Symbol">(</a><a id="11747" href="_site/2016/03/20/one-lambda-calculus-many-times/#11747" class="Bound">A</a> <a id="11749" class="Symbol">:</a> <a id="11751" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="11755" href="_site/2016/03/20/one-lambda-calculus-many-times/#11739" class="Bound">a</a><a id="11756" class="Symbol">)</a> <a id="11758" class="Symbol">(</a><a id="11759" href="_site/2016/03/20/one-lambda-calculus-many-times/#11759" class="Bound">B</a> <a id="11761" class="Symbol">:</a> <a id="11763" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="11767" href="_site/2016/03/20/one-lambda-calculus-many-times/#11743" class="Bound">b</a><a id="11768" class="Symbol">)</a> <a id="11770" class="Symbol">:</a> <a id="11772" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="11776" class="Symbol">(</a><a id="11777" href="_site/2016/03/20/one-lambda-calculus-many-times/#11739" class="Bound">a</a> <a id="11779" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="11781" href="_site/2016/03/20/one-lambda-calculus-many-times/#11743" class="Bound">b</a><a id="11782" class="Symbol">)</a> <a id="11784" class="Keyword">where</a>
  <a id="11792" class="Keyword">field</a>
    <a id="Interpret.⟦_⟧"></a><a id="11802" href="_site/2016/03/20/one-lambda-calculus-many-times/#11802" class="Field Operator">⟦_⟧</a> <a id="11806" class="Symbol">:</a> <a id="11808" href="_site/2016/03/20/one-lambda-calculus-many-times/#11747" class="Bound">A</a> <a id="11810" class="Symbol">→</a> <a id="11812" href="_site/2016/03/20/one-lambda-calculus-many-times/#11759" class="Bound">B</a>
<a id="11814" class="Keyword">open</a> <a id="11819" href="_site/2016/03/20/one-lambda-calculus-many-times/#11728" class="Module">Interpret</a> <a id="11829" class="Symbol">{{...}}</a>
</pre><p>Now, in order to interpret natural deduction proofs in Agda, we’ll need an interpretation for the atomic types. Below we say as much:</p><pre class="Agda"><a id="11981" class="Keyword">module</a> <a id="Semantics"></a><a id="11988" href="_site/2016/03/20/one-lambda-calculus-many-times/#11988" class="Module">Semantics</a> <a id="11998" class="Symbol">(</a><a id="11999" href="_site/2016/03/20/one-lambda-calculus-many-times/#11999" class="Bound">Atom</a> <a id="12004" class="Symbol">:</a> <a id="12006" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="12009" class="Symbol">)</a> <a id="12011" class="Symbol">{{</a><a id="12013" href="_site/2016/03/20/one-lambda-calculus-many-times/#12013" class="Bound">InterpretAtom</a> <a id="12027" class="Symbol">:</a> <a id="12029" href="_site/2016/03/20/one-lambda-calculus-many-times/#11728" class="Record">Interpret</a> <a id="12039" href="_site/2016/03/20/one-lambda-calculus-many-times/#11999" class="Bound">Atom</a> <a id="12044" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a><a id="12047" class="Symbol">}}</a> <a id="12050" class="Keyword">where</a>
</pre><p>Unsurprisingly, we interpret the implication as Agda’s function type:</p><pre class="Agda">  <a id="12764" class="Keyword">instance</a>
    <a id="Semantics.InterpretType"></a><a id="12777" href="_site/2016/03/20/one-lambda-calculus-many-times/#12777" class="Function">InterpretType</a> <a id="12791" class="Symbol">:</a> <a id="12793" href="_site/2016/03/20/one-lambda-calculus-many-times/#11728" class="Record">Interpret</a> <a id="12803" href="_site/2016/03/20/one-lambda-calculus-many-times/#2219" class="Datatype">Type</a> <a id="12808" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
    <a id="12816" href="_site/2016/03/20/one-lambda-calculus-many-times/#12777" class="Function">InterpretType</a> <a id="12830" class="Symbol">=</a> <a id="12832" class="Keyword">record</a> <a id="12839" class="Symbol">{</a> <a id="12841" href="_site/2016/03/20/one-lambda-calculus-many-times/#11802" class="Field Operator">⟦_⟧</a> <a id="12845" class="Symbol">=</a> <a id="12847" href="_site/2016/03/20/one-lambda-calculus-many-times/#12874" class="Function Operator">⟦_⟧′</a> <a id="12852" class="Symbol">}</a>
      <a id="12860" class="Keyword">where</a>
        <a id="12874" href="_site/2016/03/20/one-lambda-calculus-many-times/#12874" class="Function Operator">⟦_⟧′</a>  <a id="12880" class="Symbol">:</a> <a id="12882" href="_site/2016/03/20/one-lambda-calculus-many-times/#2219" class="Datatype">Type</a> <a id="12887" class="Symbol">→</a> <a id="12889" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
        <a id="12901" href="_site/2016/03/20/one-lambda-calculus-many-times/#12874" class="Function Operator">⟦</a> <a id="12903" href="_site/2016/03/20/one-lambda-calculus-many-times/#2240" class="InductiveConstructor">El</a>  <a id="12907" href="_site/2016/03/20/one-lambda-calculus-many-times/#12907" class="Bound">A</a> <a id="12909" href="_site/2016/03/20/one-lambda-calculus-many-times/#12874" class="Function Operator">⟧′</a> <a id="12912" class="Symbol">=</a> <a id="12914" href="_site/2016/03/20/one-lambda-calculus-many-times/#11802" class="Field Operator">⟦</a> <a id="12916" href="_site/2016/03/20/one-lambda-calculus-many-times/#12907" class="Bound">A</a> <a id="12918" href="_site/2016/03/20/one-lambda-calculus-many-times/#11802" class="Field Operator">⟧</a>
        <a id="12928" href="_site/2016/03/20/one-lambda-calculus-many-times/#12874" class="Function Operator">⟦</a> <a id="12930" href="_site/2016/03/20/one-lambda-calculus-many-times/#12930" class="Bound">A</a> <a id="12932" href="_site/2016/03/20/one-lambda-calculus-many-times/#2262" class="InductiveConstructor Operator">⇒</a> <a id="12934" href="_site/2016/03/20/one-lambda-calculus-many-times/#12934" class="Bound">B</a> <a id="12936" href="_site/2016/03/20/one-lambda-calculus-many-times/#12874" class="Function Operator">⟧′</a> <a id="12939" class="Symbol">=</a> <a id="12941" href="_site/2016/03/20/one-lambda-calculus-many-times/#12874" class="Function Operator">⟦</a> <a id="12943" href="_site/2016/03/20/one-lambda-calculus-many-times/#12930" class="Bound">A</a> <a id="12945" href="_site/2016/03/20/one-lambda-calculus-many-times/#12874" class="Function Operator">⟧′</a> <a id="12948" class="Symbol">→</a> <a id="12950" href="_site/2016/03/20/one-lambda-calculus-many-times/#12874" class="Function Operator">⟦</a> <a id="12952" href="_site/2016/03/20/one-lambda-calculus-many-times/#12934" class="Bound">B</a> <a id="12954" href="_site/2016/03/20/one-lambda-calculus-many-times/#12874" class="Function Operator">⟧′</a>
</pre><p>In order to interpret sequents, we’ll need an interpretation for the antecedent. For this we’ll create a type for <em>environments</em>, <a class="Agda Datatype">Env</a>, which is indexed by a list of types, and which stores values of the <em>interpretations</em> of those types:</p><pre class="Agda">  <a id="13235" class="Keyword">infixr</a> <a id="13242" class="Number">5</a> <a id="13244" href="_site/2016/03/20/one-lambda-calculus-many-times/#13305" class="InductiveConstructor Operator">_∷_</a>

  <a id="13251" class="Keyword">data</a> <a id="Semantics.Env"></a><a id="13256" href="_site/2016/03/20/one-lambda-calculus-many-times/#13256" class="Datatype">Env</a> <a id="13260" class="Symbol">:</a> <a id="13262" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="13267" href="_site/2016/03/20/one-lambda-calculus-many-times/#2219" class="Datatype">Type</a> <a id="13272" class="Symbol">→</a> <a id="13274" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a> <a id="13278" class="Keyword">where</a>
    <a id="Semantics.Env.[]"></a><a id="13288" href="_site/2016/03/20/one-lambda-calculus-many-times/#13288" class="InductiveConstructor">[]</a>  <a id="13292" class="Symbol">:</a> <a id="13294" href="_site/2016/03/20/one-lambda-calculus-many-times/#13256" class="Datatype">Env</a> <a id="13298" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
    <a id="Semantics.Env._∷_"></a><a id="13305" href="_site/2016/03/20/one-lambda-calculus-many-times/#13305" class="InductiveConstructor Operator">_∷_</a> <a id="13309" class="Symbol">:</a> <a id="13311" href="_site/2016/03/20/one-lambda-calculus-many-times/#11802" class="Field Operator">⟦</a> <a id="13313" href="_site/2016/03/20/one-lambda-calculus-many-times/#5126" class="Generalizable">A</a> <a id="13315" href="_site/2016/03/20/one-lambda-calculus-many-times/#11802" class="Field Operator">⟧</a> <a id="13317" class="Symbol">→</a> <a id="13319" href="_site/2016/03/20/one-lambda-calculus-many-times/#13256" class="Datatype">Env</a> <a id="13323" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="13325" class="Symbol">→</a> <a id="13327" href="_site/2016/03/20/one-lambda-calculus-many-times/#13256" class="Datatype">Env</a> <a id="13331" class="Symbol">(</a><a id="13332" href="_site/2016/03/20/one-lambda-calculus-many-times/#5126" class="Generalizable">A</a> <a id="13334" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="13336" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a><a id="13337" class="Symbol">)</a>
</pre><p>Using this, we can interpret sequents as functions from environments to values:</p><pre class="Agda">  <a id="13431" class="Keyword">instance</a>
    <a id="Semantics.InterpretSequent"></a><a id="13444" href="_site/2016/03/20/one-lambda-calculus-many-times/#13444" class="Function">InterpretSequent</a> <a id="13461" class="Symbol">:</a> <a id="13463" href="_site/2016/03/20/one-lambda-calculus-many-times/#11728" class="Record">Interpret</a> <a id="13473" href="_site/2016/03/20/one-lambda-calculus-many-times/#3653" class="Datatype">Sequent</a> <a id="13481" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
    <a id="13489" href="_site/2016/03/20/one-lambda-calculus-many-times/#13444" class="Function">InterpretSequent</a> <a id="13506" class="Symbol">=</a> <a id="13508" class="Keyword">record</a> <a id="13515" class="Symbol">{</a> <a id="13517" href="_site/2016/03/20/one-lambda-calculus-many-times/#11802" class="Field Operator">⟦_⟧</a> <a id="13521" class="Symbol">=</a> <a id="13523" href="_site/2016/03/20/one-lambda-calculus-many-times/#13550" class="Function Operator">⟦_⟧′</a> <a id="13528" class="Symbol">}</a>
      <a id="13536" class="Keyword">where</a>
        <a id="13550" href="_site/2016/03/20/one-lambda-calculus-many-times/#13550" class="Function Operator">⟦_⟧′</a> <a id="13555" class="Symbol">:</a> <a id="13557" href="_site/2016/03/20/one-lambda-calculus-many-times/#3653" class="Datatype">Sequent</a> <a id="13565" class="Symbol">→</a> <a id="13567" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Primitive.html#326" class="Primitive">Set</a>
        <a id="13579" href="_site/2016/03/20/one-lambda-calculus-many-times/#13550" class="Function Operator">⟦</a> <a id="13581" href="_site/2016/03/20/one-lambda-calculus-many-times/#13581" class="Bound">Γ</a> <a id="13583" href="_site/2016/03/20/one-lambda-calculus-many-times/#3677" class="InductiveConstructor Operator">⊢</a> <a id="13585" href="_site/2016/03/20/one-lambda-calculus-many-times/#13585" class="Bound">A</a> <a id="13587" href="_site/2016/03/20/one-lambda-calculus-many-times/#13550" class="Function Operator">⟧′</a> <a id="13590" class="Symbol">=</a> <a id="13592" href="_site/2016/03/20/one-lambda-calculus-many-times/#13256" class="Datatype">Env</a> <a id="13596" href="_site/2016/03/20/one-lambda-calculus-many-times/#13581" class="Bound">Γ</a> <a id="13598" class="Symbol">→</a> <a id="13600" href="_site/2016/03/20/one-lambda-calculus-many-times/#11802" class="Field Operator">⟦</a> <a id="13602" href="_site/2016/03/20/one-lambda-calculus-many-times/#13585" class="Bound">A</a> <a id="13604" href="_site/2016/03/20/one-lambda-calculus-many-times/#11802" class="Field Operator">⟧</a>
</pre><p>Let’s get to interpreting terms! First off, variables. We can interpret variables simply by looking them up in the environment:</p><pre class="Agda">  <a id="Semantics.lookup"></a><a id="13746" href="_site/2016/03/20/one-lambda-calculus-many-times/#13746" class="Function">lookup</a> <a id="13753" class="Symbol">:</a> <a id="13755" href="_site/2016/03/20/one-lambda-calculus-many-times/#5126" class="Generalizable">A</a> <a id="13757" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Membership.Setoid.html#887" class="Function Operator">∈</a> <a id="13759" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="13761" class="Symbol">→</a> <a id="13763" href="_site/2016/03/20/one-lambda-calculus-many-times/#13256" class="Datatype">Env</a> <a id="13767" href="_site/2016/03/20/one-lambda-calculus-many-times/#5150" class="Generalizable">Γ</a> <a id="13769" class="Symbol">→</a> <a id="13771" href="_site/2016/03/20/one-lambda-calculus-many-times/#11802" class="Field Operator">⟦</a> <a id="13773" href="_site/2016/03/20/one-lambda-calculus-many-times/#5126" class="Generalizable">A</a> <a id="13775" href="_site/2016/03/20/one-lambda-calculus-many-times/#11802" class="Field Operator">⟧</a>
  <a id="13779" href="_site/2016/03/20/one-lambda-calculus-many-times/#13746" class="Function">lookup</a> <a id="13786" class="Symbol">(</a><a id="13787" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html#1219" class="InductiveConstructor">here</a> <a id="13792" href="https://agda.github.io/agda-stdlib/v1.7.1/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="13796" class="Symbol">)</a> <a id="13798" class="Symbol">(</a><a id="13799" href="_site/2016/03/20/one-lambda-calculus-many-times/#13799" class="Bound">x</a> <a id="13801" href="_site/2016/03/20/one-lambda-calculus-many-times/#13305" class="InductiveConstructor Operator">∷</a> <a id="13803" class="Symbol">_)</a> <a id="13806" class="Symbol">=</a> <a id="13808" href="_site/2016/03/20/one-lambda-calculus-many-times/#13799" class="Bound">x</a>
  <a id="13812" href="_site/2016/03/20/one-lambda-calculus-many-times/#13746" class="Function">lookup</a> <a id="13819" class="Symbol">(</a><a id="13820" href="https://agda.github.io/agda-stdlib/v1.7.1/Data.List.Relation.Unary.Any.html#1272" class="InductiveConstructor">there</a> <a id="13826" href="_site/2016/03/20/one-lambda-calculus-many-times/#13826" class="Bound">A∈Γ</a><a id="13829" class="Symbol">)</a> <a id="13831" class="Symbol">(_</a> <a id="13834" href="_site/2016/03/20/one-lambda-calculus-many-times/#13305" class="InductiveConstructor Operator">∷</a> <a id="13836" href="_site/2016/03/20/one-lambda-calculus-many-times/#13836" class="Bound">e</a><a id="13837" class="Symbol">)</a> <a id="13839" class="Symbol">=</a> <a id="13841" href="_site/2016/03/20/one-lambda-calculus-many-times/#13746" class="Function">lookup</a> <a id="13848" href="_site/2016/03/20/one-lambda-calculus-many-times/#13826" class="Bound">A∈Γ</a> <a id="13852" href="_site/2016/03/20/one-lambda-calculus-many-times/#13836" class="Bound">e</a>
</pre><p>(If you’re wondering what we’re rewriting by: the <a class="Agda InductiveConstructor">here</a> constructor carries a small proof that the element at the top of the list is <em>really</em> the element you were looking for.)</p><p>The translation for natural deduction proofs is, of course, completely routine—we translate variables withs lookups, introductions by abstractions and eliminations by applications:</p><pre class="Agda">  <a id="14268" class="Keyword">instance</a>
    <a id="Semantics.InterpretND"></a><a id="14281" href="_site/2016/03/20/one-lambda-calculus-many-times/#14281" class="Function">InterpretND</a> <a id="14293" class="Symbol">:</a> <a id="14295" href="_site/2016/03/20/one-lambda-calculus-many-times/#11728" class="Record">Interpret</a> <a id="14305" class="Symbol">(</a><a id="14306" href="_site/2016/03/20/one-lambda-calculus-many-times/#5356" class="Datatype Operator">ND</a> <a id="14309" href="_site/2016/03/20/one-lambda-calculus-many-times/#5179" class="Generalizable">S</a><a id="14310" class="Symbol">)</a> <a id="14312" href="_site/2016/03/20/one-lambda-calculus-many-times/#11802" class="Field Operator">⟦</a> <a id="14314" href="_site/2016/03/20/one-lambda-calculus-many-times/#5179" class="Generalizable">S</a> <a id="14316" href="_site/2016/03/20/one-lambda-calculus-many-times/#11802" class="Field Operator">⟧</a>
    <a id="14322" href="_site/2016/03/20/one-lambda-calculus-many-times/#14281" class="Function">InterpretND</a> <a id="14334" class="Symbol">=</a> <a id="14336" class="Keyword">record</a> <a id="14343" class="Symbol">{</a> <a id="14345" href="_site/2016/03/20/one-lambda-calculus-many-times/#11802" class="Field Operator">⟦_⟧</a> <a id="14349" class="Symbol">=</a> <a id="14351" href="_site/2016/03/20/one-lambda-calculus-many-times/#14378" class="Function Operator">⟦_⟧′</a> <a id="14356" class="Symbol">}</a>
      <a id="14364" class="Keyword">where</a>
        <a id="14378" href="_site/2016/03/20/one-lambda-calculus-many-times/#14378" class="Function Operator">⟦_⟧′</a> <a id="14383" class="Symbol">:</a> <a id="14385" href="_site/2016/03/20/one-lambda-calculus-many-times/#5356" class="Datatype Operator">ND</a> <a id="14388" href="_site/2016/03/20/one-lambda-calculus-many-times/#5179" class="Generalizable">S</a> <a id="14390" class="Symbol">→</a> <a id="14392" href="_site/2016/03/20/one-lambda-calculus-many-times/#11802" class="Field Operator">⟦</a> <a id="14394" href="_site/2016/03/20/one-lambda-calculus-many-times/#5179" class="Generalizable">S</a> <a id="14396" href="_site/2016/03/20/one-lambda-calculus-many-times/#11802" class="Field Operator">⟧</a>
        <a id="14406" href="_site/2016/03/20/one-lambda-calculus-many-times/#14378" class="Function Operator">⟦</a> <a id="14408" href="_site/2016/03/20/one-lambda-calculus-many-times/#5386" class="InductiveConstructor">ax</a> <a id="14411" href="_site/2016/03/20/one-lambda-calculus-many-times/#14411" class="Bound">p</a>   <a id="14415" href="_site/2016/03/20/one-lambda-calculus-many-times/#14378" class="Function Operator">⟧′</a> <a id="14418" href="_site/2016/03/20/one-lambda-calculus-many-times/#14418" class="Bound">e</a> <a id="14420" class="Symbol">=</a> <a id="14422" href="_site/2016/03/20/one-lambda-calculus-many-times/#13746" class="Function">lookup</a> <a id="14429" href="_site/2016/03/20/one-lambda-calculus-many-times/#14411" class="Bound">p</a> <a id="14431" href="_site/2016/03/20/one-lambda-calculus-many-times/#14418" class="Bound">e</a>
        <a id="14441" href="_site/2016/03/20/one-lambda-calculus-many-times/#14378" class="Function Operator">⟦</a> <a id="14443" href="_site/2016/03/20/one-lambda-calculus-many-times/#5412" class="InductiveConstructor">⇒i</a> <a id="14446" href="_site/2016/03/20/one-lambda-calculus-many-times/#14446" class="Bound">f</a>   <a id="14450" href="_site/2016/03/20/one-lambda-calculus-many-times/#14378" class="Function Operator">⟧′</a> <a id="14453" href="_site/2016/03/20/one-lambda-calculus-many-times/#14453" class="Bound">e</a> <a id="14455" class="Symbol">=</a> <a id="14457" class="Symbol">λ</a> <a id="14459" href="_site/2016/03/20/one-lambda-calculus-many-times/#14459" class="Bound">x</a> <a id="14461" class="Symbol">→</a> <a id="14463" href="_site/2016/03/20/one-lambda-calculus-many-times/#14378" class="Function Operator">⟦</a> <a id="14465" href="_site/2016/03/20/one-lambda-calculus-many-times/#14446" class="Bound">f</a> <a id="14467" href="_site/2016/03/20/one-lambda-calculus-many-times/#14378" class="Function Operator">⟧′</a> <a id="14470" class="Symbol">(</a><a id="14471" href="_site/2016/03/20/one-lambda-calculus-many-times/#14459" class="Bound">x</a> <a id="14473" href="_site/2016/03/20/one-lambda-calculus-many-times/#13305" class="InductiveConstructor Operator">∷</a> <a id="14475" href="_site/2016/03/20/one-lambda-calculus-many-times/#14453" class="Bound">e</a><a id="14476" class="Symbol">)</a>
        <a id="14486" href="_site/2016/03/20/one-lambda-calculus-many-times/#14378" class="Function Operator">⟦</a> <a id="14488" href="_site/2016/03/20/one-lambda-calculus-many-times/#5449" class="InductiveConstructor">⇒e</a> <a id="14491" href="_site/2016/03/20/one-lambda-calculus-many-times/#14491" class="Bound">f</a> <a id="14493" href="_site/2016/03/20/one-lambda-calculus-many-times/#14493" class="Bound">g</a> <a id="14495" href="_site/2016/03/20/one-lambda-calculus-many-times/#14378" class="Function Operator">⟧′</a> <a id="14498" href="_site/2016/03/20/one-lambda-calculus-many-times/#14498" class="Bound">e</a> <a id="14500" class="Symbol">=</a> <a id="14502" class="Symbol">(</a><a id="14503" href="_site/2016/03/20/one-lambda-calculus-many-times/#14378" class="Function Operator">⟦</a> <a id="14505" href="_site/2016/03/20/one-lambda-calculus-many-times/#14491" class="Bound">f</a> <a id="14507" href="_site/2016/03/20/one-lambda-calculus-many-times/#14378" class="Function Operator">⟧′</a> <a id="14510" href="_site/2016/03/20/one-lambda-calculus-many-times/#14498" class="Bound">e</a><a id="14511" class="Symbol">)</a> <a id="14513" class="Symbol">(</a><a id="14514" href="_site/2016/03/20/one-lambda-calculus-many-times/#14378" class="Function Operator">⟦</a> <a id="14516" href="_site/2016/03/20/one-lambda-calculus-many-times/#14493" class="Bound">g</a> <a id="14518" href="_site/2016/03/20/one-lambda-calculus-many-times/#14378" class="Function Operator">⟧′</a> <a id="14521" href="_site/2016/03/20/one-lambda-calculus-many-times/#14498" class="Bound">e</a><a id="14522" class="Symbol">)</a>
</pre><p>Hooray! And even better, as a corollary, we immediately obtain a translation from sequent calculus into Agda:</p><pre class="Agda">  <a id="14647" class="Keyword">instance</a>
    <a id="Semantics.InterpretSC"></a><a id="14660" href="_site/2016/03/20/one-lambda-calculus-many-times/#14660" class="Function">InterpretSC</a> <a id="14672" class="Symbol">:</a> <a id="14674" href="_site/2016/03/20/one-lambda-calculus-many-times/#11728" class="Record">Interpret</a> <a id="14684" class="Symbol">(</a><a id="14685" href="_site/2016/03/20/one-lambda-calculus-many-times/#9247" class="Datatype Operator">SC</a> <a id="14688" href="_site/2016/03/20/one-lambda-calculus-many-times/#5179" class="Generalizable">S</a><a id="14689" class="Symbol">)</a> <a id="14691" href="_site/2016/03/20/one-lambda-calculus-many-times/#11802" class="Field Operator">⟦</a> <a id="14693" href="_site/2016/03/20/one-lambda-calculus-many-times/#5179" class="Generalizable">S</a> <a id="14695" href="_site/2016/03/20/one-lambda-calculus-many-times/#11802" class="Field Operator">⟧</a>
    <a id="14701" href="_site/2016/03/20/one-lambda-calculus-many-times/#14660" class="Function">InterpretSC</a> <a id="14713" class="Symbol">=</a> <a id="14715" class="Keyword">record</a> <a id="14722" class="Symbol">{</a> <a id="14724" href="_site/2016/03/20/one-lambda-calculus-many-times/#11802" class="Field Operator">⟦_⟧</a> <a id="14728" class="Symbol">=</a> <a id="14730" href="_site/2016/03/20/one-lambda-calculus-many-times/#11802" class="Field Operator">⟦_⟧</a> <a id="14734" href="https://agda.github.io/agda-stdlib/v1.7.1/Function.Base.html#1031" class="Function Operator">∘</a> <a id="14736" href="_site/2016/03/20/one-lambda-calculus-many-times/#10068" class="Function">ND⇔SC.⟸</a> <a id="14744" class="Symbol">}</a>
</pre><p>Which means that we’ve now implemented the following functions:</p><p><span class="math display">\begin{array}{ccc} ND &amp; \rightarrow &amp; Agda \\ \\ \updownarrow \\ \\ SC \\ \end{array}</span></p><p>If you are looking for more reading on this topic, I can recommend the highly readible <em><a href="http://journals.cambridge.org/action/displayAbstract?fromPage=online&amp;aid=44279#">Lambda terms for natural deduction, sequent calculus and cut elimination</a></em> by Henk Barendregt and Silvia Ghilezan.</p><p>Next time, I’ll talk about Gentzen’s LJ, which has explicit structural rules, and variations which use other, non-list structures as the antecedent.</p><hr><section class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1" role="doc-endnote"><p>This is a good time to note that I’m not showing any of the import statements. If you wish to see them, they’re there in the HTML source. However, it may be much easier to click the symbol that confuses you—that should take you directly to its definition in the standard library.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section></article></main></body></html>