<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>All The Language</title>
    <link>https://wen.works</link>
    <description>
      <![CDATA[Personal website of Wen Kokke]]>
    </description>
    <atom:link href="https://wen.works/rss.xml" rel="self" type="application/rss+xml" />
    <lastBuildDate>Fri, 28 Jan 2022 17:23:05 +0000</lastBuildDate>
        <item>
      <title>A Tale of Three Constructed Languages</title>
      <link>https://wen.works/2021/06/15/a-tale-of-three-constructed-languages/index.html</link>
      <description>
        <![CDATA[
                  Today, we’re gonna talk about conlangs! Conlang is short for constructed language. There’s a bunch of famous conlangs. Esperanto is probably the most famous of the idealistic “let’s unite the world” conlangs—it’s pretty old, going back to the late 1870s. In the 1930s, some dude named Jerry Tolkien published a whole series of fantasy novels just to popularise z$5h#1 and his other conlangs, an effort we can say was at least passably successful. In recent decades, we got tlhIngan Hol, lekh dothraki and Valyrio udrir, each of which now have communities of speakers formed around them. Heck, two of those even got their’s own DuoLingo course!2 Unfortunately, one thing all these languages share is that they were created by dudes…
        ]]>
      </description>
      <pubDate>Tue, 15 Jun 2021 12:00:00 +0000</pubDate>
      <guid>https://wen.works/2021/06/15/a-tale-of-three-constructed-languages/index.html</guid>
      <dc:creator>Wen Kokke</dc:creator>
    </item>
        <item>
      <title>An Introduction to Session Types</title>
      <link>https://wen.works/2020/12/17/an-introduction-to-session-types/index.html</link>
      <description>
        <![CDATA[
                  Session types. Ostensibly, I’ve studied them for the past few years, so I should know something about them, right? I am gonna try and explain the foundations of session types, and along the way, there will be programs which crash, Victorian ladies having milk puddings, and tin can telephones.
        ]]>
      </description>
      <pubDate>Thu, 17 Dec 2020 12:00:00 +0000</pubDate>
      <guid>https://wen.works/2020/12/17/an-introduction-to-session-types/index.html</guid>
      <dc:creator>Wen Kokke</dc:creator>
    </item>
        <item>
      <title>Neural Networks with Cube Cats</title>
      <link>https://wen.works/2020/09/12/neural-networks-with-cube-cats/index.html</link>
      <description>
        <![CDATA[
                  Neural Networks. They’re, uh, pretty pervasive by now, so you’ve probably heard of them, telling you which of your friends is in that picture, and that they know what you wanna text better than you do. But what do they know? Do they know things? Let’s find out!
        ]]>
      </description>
      <pubDate>Sat, 12 Sep 2020 12:00:00 +0000</pubDate>
      <guid>https://wen.works/2020/09/12/neural-networks-with-cube-cats/index.html</guid>
      <dc:creator>Wen Kokke</dc:creator>
    </item>
        <item>
      <title>Paper Girls, Substitution Ciphers, and Frequency Analysis</title>
      <link>https://wen.works/2018/12/09/paper-girls-substitution-ciphers-and-frequency-analysis/index.html</link>
      <description>
        <![CDATA[
                  
                  WARNING! IF YOU’RE READING THIS, YOU’RE DOING IT WRONG. CLICK THE LINK, READ IT ON MY BLOG. IT’LL BE WAY LESs CONFUSING. ANYWAY. THIS WEeKEND, I PICKED UP A COPY OF PAPER GIRLS, A MYSTERY/SCIENCE FICTION COMIC ABOUT FOUR GIRLS ON A PAPER ROUTE. WAIT, YOU CAN’T UNDERSTAND ME? OH, FUCK, DOESN’T LOoK LIKE IT. SORrY, LET ME ADJUST.
        ]]>
      </description>
      <pubDate>Sun, 09 Dec 2018 12:00:00 +0000</pubDate>
      <guid>https://wen.works/2018/12/09/paper-girls-substitution-ciphers-and-frequency-analysis/index.html</guid>
      <dc:creator>Wen Kokke</dc:creator>
    </item>
        <item>
      <title>VISL CG-3 is the new assembler</title>
      <link>https://wen.works/2017/05/15/visl-cg-3-is-the-new-assembler/index.html</link>
      <description>
        <![CDATA[
                  This post is a continuation of Constraint Grammar can count!, in which I talked a bunch about how expressive constraint grammar is. Now, for most of that post, what I actually meant was the fragment of constraint grammar where you only use the REMOVE rule.1 However, I always had the suspicion that I’d be pretty easy to simulate a Turing machine using only the ADDCOHORT and REMCOHORT commands, treating the list of cohorts as the Turing machine’s tape—and I don’t think I was the only one to feel that way.
        ]]>
      </description>
      <pubDate>Mon, 15 May 2017 12:00:00 +0000</pubDate>
      <guid>https://wen.works/2017/05/15/visl-cg-3-is-the-new-assembler/index.html</guid>
      <dc:creator>Wen Kokke</dc:creator>
    </item>
        <item>
      <title>Presidents, Scumbags, Kings and Arseholes, and The Great Dalmuti</title>
      <link>https://wen.works/2016/04/05/presidents-scumbags-kings-and-arseholes-and-the-great-dalmuti/index.html</link>
      <description>
        <![CDATA[
                  One of my favourite card games is The Great Dalmuti. It’s a variant of a widely-played card game with many, many names: President, Scumbag, Kings and Arseholes. Each of these may have slightly different rules, and slightly different decks, but they are all more or less the same game.
                  I’ve had a bunch of discussions about this game over the years, most of which were about the possible strategies. Personally, I don’t believe that this game is all that hard to play well—and consequently, that it isn’t all that hard to write an AI for it. Pehaps even a very simple, rule-based AI can play passably. However, friends of mine think that it is a much harder problem, and that much more advanced techniques will be needed. Therefore, I thought I’d write a little playground for AIs to play in.
        ]]>
      </description>
      <pubDate>Tue, 05 Apr 2016 12:00:00 +0000</pubDate>
      <guid>https://wen.works/2016/04/05/presidents-scumbags-kings-and-arseholes-and-the-great-dalmuti/index.html</guid>
      <dc:creator>Wen Kokke</dc:creator>
    </item>
        <item>
      <title>Breadboxes, Plenty Questions and Distributional Semantics</title>
      <link>https://wen.works/2016/03/21/breadboxes-and-distributional-semantics/index.html</link>
      <description>
        <![CDATA[
                  Quite a while ago, UnicornPower introduced me to a game called Breadbox. It’s an experimental cousin of 20 Questions, also known as Plenty Questions, which is played by two players—or more, really—who we’ll name Allie and Blake:

                  Allie thinks of something.
                  As their first question, Blake asks “Is it a breadbox?”
                  Allie—who, seeing the mandatory first question, obviously wouldn’t choose a breadbox—answers “No, it’s not!”

                  From there on out, all Blake’s questions have to be of the form…

                  “Is it more like a breadbox, or more like…?”

                  …where breadbox is replaced by whatever the current guess is, and the dots are filled in with whatever Blake wants. Let’s see if we can write an AI for playing this game!
        ]]>
      </description>
      <pubDate>Mon, 21 Mar 2016 12:00:00 +0000</pubDate>
      <guid>https://wen.works/2016/03/21/breadboxes-and-distributional-semantics/index.html</guid>
      <dc:creator>Wen Kokke</dc:creator>
    </item>
        <item>
      <title>One λ-calculus, many times…</title>
      <link>https://wen.works/2016/03/20/one-lambda-calculus-many-times/index.html</link>
      <description>
        <![CDATA[
                  
                  Previously, I mentioned that one of the most common posts on Agda blogs is implementing the simply-typed λ-calculus. Gergő Érdi even goes as far as to call it the FizzBuzz of dependently-typed programming, and rightfully so: If you do a quick search, you’ll find dozens of examples.
                  In Dependently-Typed Programming with Agda, Ulf Norell implements a type checker the simply-typed λ-calculus; Francesco Mazzoli more or less follows Ulf, but extends his λ-calculus with a primitive operator for addition; and, Gergő Érdi extends Ulf’s approach with a checker for scope and binding.
                  I figured it would be more fun if, instead of rewriting the type checker example, I would do something a little bit different. So for my λ-calculus post, I’ll have a look at kinds of different ways of implementing the simply-typed λ-calculus. Today, natural deduction and the sequent calculus.
        ]]>
      </description>
      <pubDate>Sun, 20 Mar 2016 12:00:00 +0000</pubDate>
      <guid>https://wen.works/2016/03/20/one-lambda-calculus-many-times/index.html</guid>
      <dc:creator>Wen Kokke</dc:creator>
    </item>
        <item>
      <title>Constraint Grammar can count!</title>
      <link>https://wen.works/2016/03/16/constraint-grammar-can-count/index.html</link>
      <description>
        <![CDATA[
                  Constraint grammar—it is a natural language processing formalism with great two distinctions: it routinely scores amongst the highest in tasks such as part-of-speech tagging and word-sense disambiguation, with F-scores at around 99%; and it has made some of the most dubious choices in programming language syntax in history. Though its specification has changed tremendously since CG1, it is nontheless a grammar formalism which sees a lot of usage. One natural question to ask of any grammar formalism is “how expressive is it?”
                  Over the weekend, inariksit visited me, and we decided to find out!
        ]]>
      </description>
      <pubDate>Wed, 16 Mar 2016 12:00:00 +0000</pubDate>
      <guid>https://wen.works/2016/03/16/constraint-grammar-can-count/index.html</guid>
      <dc:creator>Wen Kokke</dc:creator>
    </item>
        <item>
      <title>Side-effects in English</title>
      <link>https://wen.works/2016/03/09/side-effects-in-english/index.html</link>
      <description>
        <![CDATA[
                  Back when I wrote this, I had just discovered “Extensible Effects: an alternative to Monad Transformers” by Oleg Kiselyov, Amr Sabry, Cameron Swords, and Hiromi Ishii, and I’ve always had a penchant for mucking about with linguistics and Haskell… so… let’s have a little fun with this library and some basic AB grammars in Haskell, see how far we can get within the universally well-defined maximum length of a blog post!
        ]]>
      </description>
      <pubDate>Wed, 09 Mar 2016 12:00:00 +0000</pubDate>
      <guid>https://wen.works/2016/03/09/side-effects-in-english/index.html</guid>
      <dc:creator>Wen Kokke</dc:creator>
    </item>
        <item>
      <title>Insertion sort in Agda</title>
      <link>https://wen.works/2016/03/01/insertion-sort-in-agda/index.html</link>
      <description>
        <![CDATA[
                  
                  I wrote this code a long time ago, and verifiying the correctness of some sorting algorithm is pretty much the standard “Hello World! I can Agda!” blog post—well, that and implementing the λ-calculus—but I really wanted an excuse to test my Jekyll/Agda integration…
        ]]>
      </description>
      <pubDate>Tue, 01 Mar 2016 12:00:00 +0000</pubDate>
      <guid>https://wen.works/2016/03/01/insertion-sort-in-agda/index.html</guid>
      <dc:creator>Wen Kokke</dc:creator>
    </item>
      </channel>
</rss>