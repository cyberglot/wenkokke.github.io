<!DOCTYPE html>
<html lang="en-us">
    <head>
    <link href="http://gmpg.org/xfn/11" rel="profile">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    <!-- Enable responsiveness on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

    <title>Constraint Grammar can count!</title>

    <!-- CSS -->
    <link rel="stylesheet" href="../public/css/style.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Slab:wght@400;700|Raleway:ital,wght@0,400;0,700;1,400" rel="stylesheet"> 

    <!-- RSS -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="../rss.xml">

    

    
</head>



    <body>
        <header class="sidebar">
    <div class="container sidebar-sticky">
        <div class="sidebar-about">
            <img class="sidebar-about-photo" src="../public/images/me.png" alt="It's me!" />
            <h1><a href="https://wenkokke.github.io">All The Language</a></h1>
            <p class="lead">
                Hiya!
                I'm <span class="tooltip" title="/wɛn/">Wen</span>.
                I study natural language, programming languages and logical languages.
                Basically, all the language&hellip;
            </p>
        </div>
        <nav class="sidebar-nav">
            <a class="sidebar-nav-item" href="../">
                Blog
            </a>
            <a class="sidebar-nav-item" href="../pages/pubs.html">
                Pubs
            </a>
        </nav>
        <nav class="sidebar-nav">
            <a class="sidebar-nav-item sidebar-nav-icon" href="mailto:me@wen.works">
                <i class="far fa-envelope"></i>
            </a>
            <a class="sidebar-nav-item sidebar-nav-icon" href="https://github.com/wenkokke">
                <i class="fab fa-github"></i>
            </a>
            <a class="sidebar-nav-item sidebar-nav-icon" href="https://twitter.com/wenkokke">
                <i class="fab fa-twitter"></i>
            </a>
            <a class="sidebar-nav-item sidebar-nav-icon" href="https://www.paypal.me/wenkokke">
                <i class="fab fa-paypal"></i>
            </a>
        </nav>
        <div class="sidebar-about">
            &copy; 2020. All rights reserved.
        </div>
    </div>
</header>

        <main class="content container">
            <article class="post">
    <header>
        <h1 class="post-title">Constraint Grammar can count!</h1>
    </header>
    <footer class="post-date">
        March 16, 2016
    </footer>
    <p>Constraint grammar—it is a natural language processing formalism with great two distinctions: it routinely scores amongst the highest in tasks such as part-of-speech tagging and word-sense disambiguation, with F-scores at around 99%; and it has made some of the most dubious choices in programming language syntax in history. Though its specification has changed tremendously since CG1, it is nontheless a grammar formalism which sees a lot of usage. One natural question to ask of any grammar formalism is “how expressive is it?”</p>
<p>Over the weekend, <a href="https://github.com/inariksit">inariksit</a> visited me, and we decided to find out!</p>
<!--more-->
<p>It’s not immediately obvious how to even approach this question, as constraint grammar doesn’t <em>generate</em> strings per se. It simply <em>constrains</em> existing, ambiguous strings. We took the following approach: we view a constraint grammar as a formal language <span class="math inline">ℒ</span>, generated over an alphabet <span class="math inline"><em>Σ</em></span>. We generate the strings in our language by passing maximally ambiguous strings of <em>every</em> length to the grammar. With maximally ambiguous, I mean those strings where each position contains the entire alphabet, so <span class="math inline">⟨<em>Σ</em>⟩<sub><em>n</em></sub></span>. A constraint grammar is said to <em>accept</em> a string <span class="math inline"><em>w</em></span> of length <span class="math inline"><em>n</em></span> if, when we pass <span class="math inline">⟨<em>Σ</em>⟩<sub><em>n</em></sub></span> as an input to the CG, <span class="math inline"><em>w</em></span> is one of the possible interpretations of its output.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>The specification of CG3 mentions tags such as <code>EXTERNAL</code>, which passes information to an external command. So constraint grammar is obviously Turing complete. However, that’s a little bit boring, so let’s see what we can say about the expressiveness of the absolute core of constraint grammar: <code>REMOVE</code> with sections. If we leave out sections, there is no recursion, and therefore the language will be strictly finite and boring. If we leave out <code>REMOVE</code> then there is no way to restrict strings, so we’d only have the languages <span class="math inline"><em>Σ</em><sup>*</sup></span> for any <span class="math inline"><em>Σ</em></span>.</p>
<p>There are a few concessions we will allow ourselves. If we had <code>MAP</code>, <code>ADD</code>, or any such other command, we would have a way to store information. In this strict fragment, all we have is the current set of symbol assignments. Therefore, we will allow ourselves a second alphabet <span class="math inline"><em>Σ</em>′</span> of <em>hidden</em> symbols—i.e. symbols that we are not allowed to pass to the output. In addition, we update our definition of <span class="math inline">ℒ</span> to state that we pass in <span class="math inline">⟨<em>Σ</em> ∪ <em>Σ</em>′⟩<sub><em>n</em></sub></span>. This is not <em>strictly</em> necessary in CG3, as we could use <code>APPEND</code> to add these hidden characters, but we would like to stay as faithful to our fragment as possible.</p>
<p>One last hurdle is that constraint grammar has no notion of <em>failure</em>. The worst that can happen is that a grammar changes nothing. Worse so, if there is only one reading left, the <code>REMOVE</code> command will have no effect. So one more concession we make is that we allow ourselves to use the <code>REMCOHORT</code> command—which removes an entire “cohort”, or “position” in our terminology—for the <em>sole purpose</em> of deleting the entire string if it is not accepted.</p>
<p>From here on out, when we say ‘CG3’, we are referring to this fragment of constraint grammar.</p>
<h3 id="cg3-is-not-regular-the-language-anbn">CG3 is not regular; the language <span class="math inline"><em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup></span></h3>
<p>In this section we show that CG3, restricted to sections and <code>REMOVE</code> is not regular. We show this by implementing a grammar for the counting language <span class="math inline"><em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup></span>.</p>
<p>The first thing we do is to try and detect the edges of the string. CG3 has “magical” constants for this, called <code>&gt;&gt;&gt;</code> and <code>&lt;&lt;&lt;</code> for the left and right edge, respectively. However, we cannot use those. Instead, we define them ourselves using two hidden variables, which we also call <code>&gt;&gt;&gt;</code> and <code>&lt;&lt;&lt;</code>. We do this as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>SET ANY <span class="op">=</span> A OR B<span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>BEFORE<span class="op">-</span>SECTIONS</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>REMOVE <span class="op">&gt;&gt;&gt;</span> (<span class="op">-</span><span class="dv">1</span> ANY)<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>REMOVE <span class="op">&lt;&lt;&lt;</span> ( <span class="dv">1</span> ANY)<span class="op">;</span></span></code></pre></div>
<p>Initially, all positions will be labeled with both <code>&gt;&gt;&gt;</code> and <code>&lt;&lt;&lt;</code>. These above rules check whether there is <em>any</em> position preceding or succeeding the current position, and if so, delete <code>&gt;&gt;&gt;</code> or <code>&lt;&lt;&lt;</code>. As a result, the first position will be the only one tagged <code>&gt;&gt;&gt;</code>, and the last the only one tagged <code>&lt;&lt;&lt;</code>.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>Next, we note that <em>all</em> strings in the language <span class="math inline"><em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup></span> are of even length, and that every even length corresponds to <em>exactly</em> one string. Therefore, we must reject all strings of uneven length. We assume two more hidden symbols, <code>EVEN</code> and <code>ODD</code>. We can use these to label whether a position is even or odd: we know the first position is odd, so we delete <code>EVEN</code>; we know that positions following odd positions must be even, so we delete <code>ODD</code>; and we know that positions following even positions are <code>ODD</code>, so we delete <code>EVEN</code>…<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>BEFORE<span class="op">-</span>SECTIONS</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>REMOVE EVEN (<span class="dv">0</span> <span class="op">&gt;&gt;&gt;</span>)<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>SECTION</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>REMOVE ODD  (NOT  <span class="dv">0</span> <span class="op">&gt;&gt;&gt;</span> LINK NOT <span class="op">-</span><span class="dv">1</span> EVEN)<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>REMOVE EVEN (NOT <span class="op">-</span><span class="dv">1</span> ODD)<span class="op">;</span></span></code></pre></div>
<p>It’s exactly this “marking as even by deleting odd” that makes it a bit of a confusing read, so if you’d like to play around with an example, <a href="https://gist.github.com/wenkokke/e5f76d82939ecc9d3a4c">my full code with examples is available here</a>, and <a href="http://beta.visl.sdu.dk/cg3/chunked/installation.html">vislcg3 is available here</a>.</p>
<p>Anyway, after performing this labelling, we can check if the last position is even, and if so, delete all positions:<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>AFTER<span class="op">-</span>SECTIONS</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>REMCOHORT ANY (<span class="dv">1</span><span class="op">*</span> <span class="op">&lt;&lt;&lt;</span> LINK NOT <span class="dv">0</span> EVEN)<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>REMCOHORT <span class="op">&lt;&lt;&lt;</span> (NOT <span class="dv">0</span> EVEN)<span class="op">;</span></span></code></pre></div>
<p>Now that we are certain that we only accept even-length strings, it is safe to say that the first symbol must be an <span class="math inline"><em>a</em></span>, and the last must be a <span class="math inline"><em>b</em></span>:<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>BEFORE<span class="op">-</span>SECTIONS</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>SELECT A (<span class="dv">0</span> <span class="op">&gt;&gt;&gt;</span>)<span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>SELECT B (<span class="dv">0</span> <span class="op">&lt;&lt;&lt;</span>)<span class="op">;</span></span></code></pre></div>
<p>And now it’s only a matter of slowly growing these <span class="math inline"><em>a</em></span>s and <span class="math inline"><em>b</em></span>s until they meet. We do this as follows: in each pass, we mark the position <em>after</em> the last definite <span class="math inline"><em>a</em></span> as a candidate for <span class="math inline"><em>a</em></span> (written <code>OPT_A</code>), and do likewise for the last position <em>before</em> the first definite <span class="math inline"><em>b</em></span>. Then we mark each candidate <span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span> as <em>definite</em>, and we continue:<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>SECTION</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>REMOVE OPT_B (<span class="op">-</span>1C A)<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>REMOVE OPT_A ( 1C B)<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>SELECT A (NOT <span class="dv">0</span> OPT_B)<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>SELECT B (NOT <span class="dv">0</span> OPT_A)<span class="op">;</span></span></code></pre></div>
<p>The grammar described so far exactly expresses the language <span class="math inline"><em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup></span>.<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> Since this language is not regular, we can conclude that constraint grammar is not regular.</p>
<h3 id="cg3-is-not-context-free-the-language-anbncn">CG3 is not context-free; the language <span class="math inline"><em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup><em>c</em><sup><em>n</em></sup></span></h3>
<p>In this section we show that CG3, restricted to sections and <code>REMOVE</code> is not context-free. We show this by implementing a grammar for the counting language <span class="math inline"><em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup><em>c</em><sup><em>n</em></sup></span>.</p>
<p>The language <span class="math inline"><em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup><em>c</em><sup><em>n</em></sup></span> has us divide strings whose length is a multiple of three into three even chunks. The first part of this is obviously to find the bounds of the input string, as before, and make sure that it has a length divisible by three. We can trivially extend our previous approach—now abandoning “even” and “odd” in favour of <code>X1</code>, <code>X2</code> and <code>X3</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>SET X1_OR_X2 <span class="op">=</span> X1 OR X2<span class="op">;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>SET X2_OR_X3 <span class="op">=</span> X2 OR X3<span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>SET X3_OR_X1 <span class="op">=</span> X3 OR X1<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>BEFORE<span class="op">-</span>SECTIONS</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>REMOVE X2_OR_X3 (<span class="dv">0</span> <span class="op">&gt;&gt;&gt;</span>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>SECTION</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>REMOVE X3_OR_X1 (NOT <span class="dv">0</span> <span class="op">&gt;&gt;&gt;</span> LINK NOT <span class="op">-</span><span class="dv">1</span> X2_OR_X3)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>REMOVE X1_OR_X2 (NOT <span class="dv">0</span> <span class="op">&gt;&gt;&gt;</span> LINK NOT <span class="op">-</span><span class="dv">1</span> X3_OR_X1)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>REMOVE X2_OR_X3 (NOT <span class="dv">0</span> <span class="op">&gt;&gt;&gt;</span> LINK NOT <span class="op">-</span><span class="dv">1</span> X1_OR_X2)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>AFTER<span class="op">-</span>SECTIONS</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>REMCOHORT ANY (<span class="dv">1</span><span class="op">*</span> <span class="op">&lt;&lt;&lt;</span> LINK NOT <span class="dv">0</span> X3)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>REMCOHORT <span class="op">&lt;&lt;&lt;</span> (NOT <span class="dv">0</span> X3)</span></code></pre></div>
<p>Note that, somewhat counterintuitively, <code>REMOVE X1_OR_X2</code><a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> removes <em>both</em> <code>X1</code> and <code>X2</code>, but <code>0 X1_OR_X2</code> matches if the current position still has either option.</p>
<p>Now that we can be sure that our string is of some length <span class="math inline">3<em>n</em></span>, we can proceed to divide it into three equal chunks. One good way to do this, is to start by finding the middle. This is <em>exactly</em> what we did in our grammar for <span class="math inline"><em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup></span>. Below we implement the same, but now <em>without</em> using <code>SELECT</code>, as using this would erase all other tags. For this, we assume four new hidden symbols <code>FST</code>, <code>SND</code>—for first and second half—and <code>OPT_*</code> varieties:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>SET NOT_FST <span class="op">=</span> OPT_FST OR SND OR OPT_SND <span class="op">;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>SET NOT_SND <span class="op">=</span> FST OR OPT_FST OR OPT_SND <span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>BEFORE<span class="op">-</span>SECTIONS</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>REMOVE NOT_FST (<span class="dv">0</span> <span class="op">&gt;&gt;&gt;</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>REMOVE NOT_SND (<span class="dv">0</span> <span class="op">&lt;&lt;&lt;</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>SECTION</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>REMOVE OPT_SND (<span class="op">-</span><span class="dv">1</span> FST LINK (NOT <span class="dv">0</span> NOT_FST))</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>REMOVE OPT_FST ( <span class="dv">1</span> SND LINK (NOT <span class="dv">0</span> NOT_SND))</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>REMOVE NOT_FST (<span class="dv">0</span> FST LINK <span class="dv">0</span> SND LINK <span class="dv">0</span> OPT_FST LINK NOT <span class="dv">0</span> OPT_SND)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>REMOVE NOT_SND (<span class="dv">0</span> FST LINK <span class="dv">0</span> SND LINK <span class="dv">0</span> OPT_SND LINK NOT <span class="dv">0</span> OPT_FST)</span></code></pre></div>
<p>Once we’ve divided the word in half, it becomes fairly easy to point out the middle. Below, we mark the first position as <span class="math inline"><em>a</em></span>, the last position as <span class="math inline"><em>c</em></span> and the middle position as <span class="math inline"><em>b</em></span>:<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>SET OPT_A_OR_B <span class="op">=</span> (OPT_A OR OPT_B)<span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>SET OPT_B_OR_C <span class="op">=</span> (OPT_A OR OPT_B)<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>SET OPT_C_OR_D <span class="op">=</span> (OPT_A OR OPT_B)<span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>BEFORE<span class="op">-</span>SECTIONS</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>REMOVE OPT_B_OR_C (<span class="dv">0</span> <span class="op">&gt;&gt;&gt;</span>)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>REMOVE OPT_A_OR_B (<span class="dv">0</span> <span class="op">&lt;&lt;&lt;</span>)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>SECTION</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>REMOVE OPT_C_OR_A (<span class="dv">0</span> FST LINK  <span class="dv">1</span> SND LINK NOT <span class="dv">0</span> FST)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>REMOVE OPT_C_OR_A (<span class="dv">0</span> SND LINK <span class="op">-</span><span class="dv">1</span> FST LINK NOT <span class="dv">0</span> SND)</span></code></pre></div>
<p>And finally, we grow <span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span>, and <span class="math inline"><em>b</em></span> and <span class="math inline"><em>c</em></span> towards one another as we did before. Note that we have to let <span class="math inline"><em>a</em></span> and <span class="math inline"><em>c</em></span> grow twice every time we grow <span class="math inline"><em>b</em></span>, because <span class="math inline"><em>b</em></span> is growing in <em>two</em> directions at the same time:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>SECTION</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>REMOVE OPT_B_OR_C (<span class="op">-</span>1C A)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>REMOVE OPT_A_OR_B ( 1C C)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>SELECT A (<span class="dv">0</span> OPT_A LINK NOT <span class="dv">0</span> OPT_B_OR_C)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>SELECT C (<span class="dv">0</span> OPT_C LINK NOT <span class="dv">0</span> OPT_A_OR_B)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>REMOVE OPT_C_OR_A ( 1C B)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>REMOVE OPT_C_OR_A (<span class="op">-</span>1C B)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>SELECT B (<span class="dv">0</span> OPT_B LINK NOT <span class="dv">0</span> OPT_C_OR_A)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>REMOVE OPT_B_OR_C (<span class="op">-</span>1C A)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>REMOVE OPT_A_OR_B ( 1C C)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a>SELECT A (<span class="dv">0</span> OPT_A LINK NOT <span class="dv">0</span> OPT_B_OR_C)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a>SELECT C (<span class="dv">0</span> OPT_C LINK NOT <span class="dv">0</span> OPT_A_OR_B)</span></code></pre></div>
<p>The grammar described so far exactly expresses the language <span class="math inline"><em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup><em>c</em><sup><em>n</em></sup></span>. Since this language is not context-free, we can conclude that constraint grammar is not context-free.</p>
<h3 id="beyond-context-free">Beyond Context-Free</h3>
<p>It seems pretty obvious that a language formalism whose only construct has the power to observe <em>all</em> of its surrounding context ends up being at least context-sensitive. I could continue. It is still fairly straightforward to generate the language <span class="math inline"><em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup><em>c</em><sup><em>n</em></sup><em>d</em><sup><em>n</em></sup></span>—divide into half, and divide halves into half—and using similar strategies, you can keep on constructing CGs which compute the counting language <span class="math inline"><em>σ</em><sub>1</sub><sup><em>n</em></sup>⋯<em>σ</em><sub><em>k</em></sub><sup><em>n</em></sup></span> for any <span class="math inline"><em>k</em></span> as long as you can come up with new strategies for prime numbers.. but this won’t do us a whole lot of good—at least, it won’t help us escape the class of context-sensitive languages.</p>
<p>So for now, let’s leave it at this. I’m a little bored of programming CG at any rate. If you want to have a go, <a href="https://gist.github.com/wenkokke/e5f76d82939ecc9d3a4c">my full code and examples are available here</a>, and <a href="http://beta.visl.sdu.dk/cg3/chunked/installation.html">vislcg3 is available here</a>.</p>
<hr />
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>An obvious downside to this approach is that for finite languages (as well as infinite ones, but duh) the CG will never stop generating the language, as we have to feed it <span class="math inline">⟨<em>Σ</em>⟩<sub><em>n</em></sub></span> <em>for every <span class="math inline"><em>n</em></span></em>. But we’re playing fast and loose here, so what gives.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>CG3’s magic constants are just outside of the string, whereas ours are right at the edge of the string. Therefore, all indices using magic constants are moved by one.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>While we use <code>BEFORE-SECTIONS</code> and <code>AFTER-SECTIONS</code> throughout this post, their usage is not strictly necessary. The grammar also works if everything is executed under a single <code>SECTION</code>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>Note that <code>LINK</code> is a conjunction, but one in which indices in the <em>second</em> argument are interpreted from the perspective of the position matched in the first.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>We have chosen to describe faillure by outputting the empty string. If we would have been more careful, we could have added a dedicated symbol for failure. However, under our current definitions we compare languages <em>minus</em> the empty string.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>We can use <code>SELECT</code>, since it is equivalent to calling <code>REMOVE</code> with the complement—i.e. remove everything <em>but</em> its argument.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>Note that <code>SELECT A</code> has no effect if <span class="math inline"><em>a</em></span> is not a valid option, and that <code>REMOVE A</code> has no effect if <span class="math inline"><em>a</em></span> is the <em>only</em> remaining option.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>We have chosen to describe faillure by outputting the empty string. If we would have been more careful, we could have added a dedicated symbol for failure. However, under our current definitions we compare languages <em>minus</em> the empty string.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>When we write <code>X_OR_Y</code>, this means that we have defined a “set” as <code>SET X1_OR_X2 = X1 OR X2;</code>. The reason for this is that CG3 does not allow the <em>inline</em> use of set primitives.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p>If the string has an even-numbered length, we in fact mark the middle <em>two</em> positions as <span class="math inline"><em>b</em></span>.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</article>



        </main>
    </body>
</html>
